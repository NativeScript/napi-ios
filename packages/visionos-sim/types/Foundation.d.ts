/// <reference types="@nativescript/objc-node-api" />

declare const NSLocaleVariantCode: string;

declare const NSNonRetainedObjectMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSFileGroupOwnerAccountName: string;

declare const NSAverageKeyValueOperator: string;

declare const NSHelpAnchorErrorKey: string;

declare const NSMallocException: string;

declare const NSMinimumKeyValueOperator: string;

declare const NSFileReadInapplicableStringEncodingError: number;

declare const NSFileHandleReadCompletionNotification: string;

declare const NSURLErrorCancelled: number;

declare const NSFileHandleConnectionAcceptedNotification: string;

declare const NSDateComponentUndefined: number;

declare const NSLocaleExemplarCharacterSet: string;

declare const NSISOLatin2StringEncoding: number;

declare const NSURLErrorCannotConnectToHost: number;

declare const NSFileHandleDataAvailableNotification: string;

declare const NSUnionOfObjectsKeyValueOperator: string;

declare const NSObjectNotAvailableException: string;

declare const NSFileSize: string;

declare const NSOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSFormattingErrorMaximum: number;

declare const NSLocaleCountryCode: string;

declare const NSURLErrorDNSLookupFailed: number;

declare const NSFileHandleNotificationFileHandleItem: string;

declare const NSStringEncodingErrorKey: string;

declare const NSUTF32BigEndianStringEncoding: number;

declare const NSFileDeviceIdentifier: string;

declare const NSInconsistentArchiveException: string;

declare const NSInternalInconsistencyException: string;

declare const NSKeyValueChangeKindKey: string;

declare const NSDefaultRunLoopMode: string;

declare const NSBundleExecutableArchitecturePPC64: number;

declare const NSURLErrorCannotDecodeContentData: number;

declare const NSURLErrorDomain: string;

declare const NSFileLockingError: number;

declare const NSLocalizedRecoveryOptionsErrorKey: string;

declare const NSFileReadInvalidFileNameError: number;

declare const NSRegistrationDomain: string;

declare const NSLocaleScriptCode: string;

declare const NSDecimalNumberDivideByZeroException: string;

declare const NSURLErrorNotConnectedToInternet: number;

declare const NSBundleDidLoadNotification: string;

declare const NSISO2022JPStringEncoding: number;

declare const NSCountKeyValueOperator: string;

declare const NSURLErrorFileIsDirectory: number;

declare const NS_LittleEndian: number;

declare const NSFileTypeSymbolicLink: string;

declare const NSURLErrorCannotOpenFile: number;

declare const NSLocaleCurrencySymbol: string;

declare const NSWindowsCP1251StringEncoding: number;

declare const NSRecoveryAttempterErrorKey: string;

declare const NSFileErrorMaximum: number;

declare const NSWillBecomeMultiThreadedNotification: string;

declare const NSURLErrorKey: string;

declare const NSProprietaryStringEncoding: number;

declare const NSLocaleUsesMetricSystem: string;

declare const NSFileWriteOutOfSpaceError: number;

declare const NSFileWriteNoPermissionError: number;

declare const NSURLErrorNoPermissionsToReadFile: number;

declare const NSLocaleMeasurementSystem: string;

declare const NSInvalidArgumentException: string;

declare const NSPointerToStructHashCallBacks: NSHashTableCallBacks;

declare const NSParseErrorException: string;

declare const NSFormattingError: number;

declare const NSURLErrorZeroByteResource: number;

declare const NSNonOwnedPointerOrNullMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSUndoCloseGroupingRunLoopOrdering: number;

declare const NSKeyValueChangeNewKey: string;

declare const NSFormattingErrorMinimum: number;

declare const NSFileExtensionHidden: string;

declare const NSFileSystemSize: string;

declare const NSLocalizedDescriptionKey: string;

declare const NSInvalidArchiveOperationException: string;

declare const NSFileReadNoSuchFileError: number;

declare const NSObjectHashCallBacks: NSHashTableCallBacks;

declare const NSURLErrorDownloadDecodingFailedToComplete: number;

declare const NSBundleExecutableArchitecturePPC: number;

declare const NSURLErrorNetworkConnectionLost: number;

declare const NSFileTypeSocket: string;

declare const NSFileHandleReadToEndOfFileCompletionNotification: string;

declare const NSMaximumKeyValueOperator: string;

declare const NSFileWriteUnsupportedSchemeError: number;

declare const NSKeyValueValidationError: number;

declare const NSObjectMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSFileTypeDirectory: string;

declare const NSUnderlyingErrorKey: string;

declare const NSURLErrorHTTPTooManyRedirects: number;

declare const NSUndefinedKeyException: string;

declare const NSMachErrorDomain: string;

declare const NSUTF32StringEncoding: number;

declare const NSDistinctUnionOfObjectsKeyValueOperator: string;

declare const NSOwnedObjectIdentityHashCallBacks: NSHashTableCallBacks;

declare const NSFileErrorMinimum: number;

declare const NSTextCheckingAllCustomTypes: number;

declare const NSFileWriteUnknownError: number;

declare const NSJapaneseEUCStringEncoding: number;

declare const NSObjectMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSSumKeyValueOperator: string;

declare const NSURLErrorTimedOut: number;

declare const NSWindowsCP1254StringEncoding: number;

declare const NSURLErrorFileDoesNotExist: number;

declare const NS_BigEndian: number;

declare const NSInvalidReceivePortException: string;

declare const NS_UnknownByteOrder: number;

declare const NSURLErrorUserCancelledAuthentication: number;

declare const NSFileOwnerAccountName: string;

declare const NSTextCheckingAllTypes: number;

declare const NSFileReadNoPermissionError: number;

declare const NSDecimalNumberExactnessException: string;

declare const NSDistinctUnionOfArraysKeyValueOperator: string;

declare const NSLocaleCurrencyCode: string;

declare const NSOperationQueueDefaultMaxConcurrentOperationCount: number;

declare const NSPOSIXErrorDomain: string;

declare const NSValidationErrorMaximum: number;

declare const NSNonOwnedPointerHashCallBacks: NSHashTableCallBacks;

declare const NSNotFound: number;

declare const NSUTF16LittleEndianStringEncoding: number;

declare const NSFilePathErrorKey: string;

declare const NSFileSystemNumber: string;

declare const NSInvalidUnarchiveOperationException: string;

declare const NSInvalidSendPortException: string;

declare const NSDistinctUnionOfSetsKeyValueOperator: string;

declare const NSFileImmutable: string;

declare const NSFileTypeBlockSpecial: string;

declare const NSFileHandleOperationException: string;

declare const NSURLErrorUnsupportedURL: number;

declare const NSCocoaErrorDomain: string;

declare const NSNEXTSTEPStringEncoding: number;

declare const NSTextCheckingAllSystemTypes: number;

declare const NSURLErrorClientCertificateRequired: number;

declare const NSURLErrorCannotLoadFromNetwork: number;

declare const NSFileWriteInapplicableStringEncodingError: number;

declare const NSLocalizedFailureReasonErrorKey: string;

declare const NSRangeException: string;

declare const NSURLErrorUserAuthenticationRequired: number;

declare const NSMacOSRomanStringEncoding: number;

declare const NSLocaleDecimalSeparator: string;

declare const NSShiftJISStringEncoding: number;

declare const NSUTF8StringEncoding: number;

declare const NSFileReadCorruptFileError: number;

declare const NSFileReadUnknownError: number;

declare const NSFileNoSuchFileError: number;

declare const NSUserDefaultsDidChangeNotification: string;

declare const NSArgumentDomain: string;

declare const NSURLErrorServerCertificateHasUnknownRoot: number;

declare const NSURLErrorDownloadDecodingFailedMidStream: number;

declare const NSFileTypeUnknown: string;

declare const NSURLErrorCannotRemoveFile: number;

declare const NSFileReferenceCount: string;

declare const NSURLErrorCannotWriteToFile: number;

declare const NSURLErrorRedirectToNonExistentLocation: number;

declare const NSURLErrorCannotCloseFile: number;

declare const NSURLErrorClientCertificateRejected: number;

declare const NSLocaleGroupingSeparator: string;

declare const NSURLErrorServerCertificateNotYetValid: number;

declare const NSURLErrorServerCertificateUntrusted: number;

declare const NSLocalizedRecoverySuggestionErrorKey: string;

declare const NSDestinationInvalidException: string;

declare const NSURLErrorCannotParseResponse: number;

declare const NSURLErrorCannotMoveFile: number;

declare const NSURLErrorCannotDecodeRawData: number;

declare const NSURLErrorResourceUnavailable: number;

declare const NSURLErrorUnknown: number;

declare const NSThreadWillExitNotification: string;

declare const NSPortDidBecomeInvalidNotification: string;

declare const NSFileHFSCreatorCode: string;

declare const NSNonOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSNonRetainedObjectMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSGlobalDomain: string;

declare const NSNonOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSKeyValueChangeOldKey: string;

declare const NSPortTimeoutException: string;

declare const NSWindowsCP1253StringEncoding: number;

declare const NSUnionOfArraysKeyValueOperator: string;

declare const NSUTF16StringEncoding: number;

declare const NSURLErrorBadURL: number;

declare const NSFileReadUnsupportedSchemeError: number;

declare const NSUTF32LittleEndianStringEncoding: number;

declare const NSOwnedPointerHashCallBacks: NSHashTableCallBacks;

declare const NSHTTPCookieSetByJavaScript: string;

declare const NSFileSystemFreeNodes: string;

declare const NSFileSystemNodes: string;

declare const NSFileSystemFreeSize: string;

declare const NSCharacterConversionException: string;

declare const NSFileCreationDate: string;

declare const NSFileAppendOnly: string;

declare const NSFileHFSTypeCode: string;

declare const NSSymbolStringEncoding: number;

declare const NSFileSystemFileNumber: string;

declare const NSFileTypeCharacterSpecial: string;

declare const NSBundleExecutableArchitectureX86_64: number;

declare const NSFileType: string;

declare const NSFileHandleNotificationDataItem: string;

declare const NSWindowsCP1252StringEncoding: number;

declare const NSDidBecomeSingleThreadedNotification: string;

declare const NSObjectInaccessibleException: string;

declare const NSFileOwnerAccountID: string;

declare const NSURLErrorSecureConnectionFailed: number;

declare const NSOSStatusErrorDomain: string;

declare const NSDecimalNumberOverflowException: string;

declare const NSPortReceiveException: string;

declare const NSPortSendException: string;

declare const NSGenericException: string;

declare const NSUTF16BigEndianStringEncoding: number;

declare const NSURLErrorCannotFindHost: number;

declare const NSUnionOfSetsKeyValueOperator: string;

declare const NSLocaleCollationIdentifier: string;

declare const NSLocaleCalendar: string;

declare const NSLocaleLanguageCode: string;

declare const NSOpenStepUnicodeReservedBase: number;

declare const NSDecimalNumberUnderflowException: string;

declare const NSWindowsCP1250StringEncoding: number;

declare const NSLocaleIdentifier: string;

declare const NSISOLatin1StringEncoding: number;

declare const NSASCIIStringEncoding: number;

declare const NSFileWriteInvalidFileNameError: number;

declare const NSFoundationVersionNumber: number;

declare const NSKeyValueChangeIndexesKey: string;

declare const NSUnicodeStringEncoding: number;

declare const NSValidationErrorMinimum: number;

declare const NSLoadedClasses: string;

declare const NSFileTypeRegular: string;

declare const NSUserCancelledError: number;

declare const NSFileBusy: string;

declare const NSURLErrorBadServerResponse: number;

declare const NSFilePosixPermissions: string;

declare const NSOldStyleException: string;

declare const NSFileModificationDate: string;

declare const NSURLErrorServerCertificateHasBadDate: number;

declare const NSNonRetainedObjectHashCallBacks: NSHashTableCallBacks;

declare const NSURLFileScheme: string;

declare const NSNonLossyASCIIStringEncoding: number;

declare const NSURLErrorCannotCreateFile: number;

declare const NSFileGroupOwnerAccountID: string;

declare const NSUserActivityTypeBrowsingWeb: string;

declare const NSBundleExecutableArchitectureI386: number;

declare const NSStringCompareOptions: {
  CaseInsensitive: 1,
  Literal: 2,
  Backwards: 4,
  Anchored: 8,
  Numeric: 64,
};

declare const NSFileCoordinatorReadingOptions: {
  WithoutChanges: 1,
  ResolvesSymbolicLink: 2,
};

declare const NSLinguisticTaggerUnit: {
  Word: 0,
  Sentence: 1,
  Paragraph: 2,
  Document: 3,
};

declare const NSByteCountFormatterUnits: {
  Default: 0,
  Bytes: 1,
  KB: 2,
  MB: 4,
  GB: 8,
  TB: 16,
  PB: 32,
  EB: 64,
  ZB: 128,
  YBOrHigher: 65280,
  All: 65535,
};

declare const NSURLCacheStoragePolicy: {
  Allowed: 0,
  AllowedInMemoryOnly: 1,
  NotAllowed: 2,
};

declare const NSRegularExpressionOptions: {
  CaseInsensitive: 1,
  AllowCommentsAndWhitespace: 2,
  IgnoreMetacharacters: 4,
  DotMatchesLineSeparators: 8,
  AnchorsMatchLines: 16,
  UseUnixLineSeparators: 32,
  UseUnicodeWordBoundaries: 64,
};

declare const NSDateComponentsFormatterZeroFormattingBehavior: {
  None: 0,
  Default: 1,
  DropLeading: 2,
  DropMiddle: 4,
  DropTrailing: 8,
  DropAll: 14,
  Pad: 65536,
};

declare const NSXMLParserError: {
  Internal: 1,
  OutOfMemory: 2,
  DocumentStart: 3,
  EmptyDocument: 4,
  PrematureDocumentEnd: 5,
  InvalidHexCharacterRef: 6,
  InvalidDecimalCharacterRef: 7,
  InvalidCharacterRef: 8,
  InvalidCharacter: 9,
  CharacterRefAtEOF: 10,
  CharacterRefInProlog: 11,
  CharacterRefInEpilog: 12,
  CharacterRefInDTD: 13,
  EntityRefAtEOF: 14,
  EntityRefInProlog: 15,
  EntityRefInEpilog: 16,
  EntityRefInDTD: 17,
  ParsedEntityRefAtEOF: 18,
  ParsedEntityRefInProlog: 19,
  ParsedEntityRefInEpilog: 20,
  ParsedEntityRefInInternalSubset: 21,
  EntityReferenceWithoutName: 22,
  EntityReferenceMissingSemi: 23,
  ParsedEntityRefNoName: 24,
  ParsedEntityRefMissingSemi: 25,
  UndeclaredEntity: 26,
  UnparsedEntity: 28,
  EntityIsExternal: 29,
  EntityIsParameter: 30,
  UnknownEncoding: 31,
  EncodingNotSupported: 32,
  StringNotStarted: 33,
  StringNotClosed: 34,
  NamespaceDeclaration: 35,
  EntityNotStarted: 36,
  EntityNotFinished: 37,
  LessThanSymbolInAttribute: 38,
  AttributeNotStarted: 39,
  AttributeNotFinished: 40,
  AttributeHasNoValue: 41,
  AttributeRedefined: 42,
  LiteralNotStarted: 43,
  LiteralNotFinished: 44,
  CommentNotFinished: 45,
  ProcessingInstructionNotStarted: 46,
  ProcessingInstructionNotFinished: 47,
  NotationNotStarted: 48,
  NotationNotFinished: 49,
  AttributeListNotStarted: 50,
  AttributeListNotFinished: 51,
  MixedContentDeclNotStarted: 52,
  MixedContentDeclNotFinished: 53,
  ElementContentDeclNotStarted: 54,
  ElementContentDeclNotFinished: 55,
  XMLDeclNotStarted: 56,
  XMLDeclNotFinished: 57,
  ConditionalSectionNotStarted: 58,
  ConditionalSectionNotFinished: 59,
  ExternalSubsetNotFinished: 60,
  DOCTYPEDeclNotFinished: 61,
  MisplacedCDATAEndString: 62,
  CDATANotFinished: 63,
  MisplacedXMLDeclaration: 64,
  SpaceRequired: 65,
  SeparatorRequired: 66,
  NMTOKENRequired: 67,
  NAMERequired: 68,
  PCDATARequired: 69,
  URIRequired: 70,
  PublicIdentifierRequired: 71,
  LTRequired: 72,
  GTRequired: 73,
  LTSlashRequired: 74,
  EqualExpected: 75,
  TagNameMismatch: 76,
  UnfinishedTag: 77,
  StandaloneValue: 78,
  InvalidEncodingName: 79,
  CommentContainsDoubleHyphen: 80,
  InvalidEncoding: 81,
  ExternalStandaloneEntity: 82,
  InvalidConditionalSection: 83,
  EntityValueRequired: 84,
  NotWellBalanced: 85,
  ExtraContent: 86,
  InvalidCharacterInEntity: 87,
  ParsedEntityRefInInternal: 88,
  EntityRefLoop: 89,
  EntityBoundary: 90,
  InvalidURI: 91,
  URIFragment: 92,
  NoDTD: 94,
  DelegateAbortedParse: 512,
};

declare const NSDateFormatterBehavior: {
  BehaviorDefault: 0,
  Behavior10_4: 1040,
};

declare const NSStringEncodingConversionOptions: {
  AllowLossy: 1,
  ExternalRepresentation: 2,
};

declare const NSKeyValueObservingOptions: {
  New: 1,
  Old: 2,
};

declare const NSTimeZoneNameStyle: {
  Standard: 0,
  ShortStandard: 1,
  DaylightSaving: 2,
  ShortDaylightSaving: 3,
  Generic: 4,
  ShortGeneric: 5,
};

declare const NSLinguisticTaggerOptions: {
  OmitWords: 1,
  OmitPunctuation: 2,
  OmitWhitespace: 4,
  OmitOther: 8,
  JoinNames: 16,
};

declare const NSURLRequestCachePolicy: {
  UseProtocolCachePolicy: 0,
  ReloadIgnoringLocalCacheData: 1,
  ReloadIgnoringLocalAndRemoteCacheData: 4,
  ReloadIgnoringCacheData: 1,
  ReturnCacheDataElseLoad: 2,
  ReturnCacheDataDontLoad: 3,
  ReloadRevalidatingCacheData: 5,
};

declare const NSHTTPCookieAcceptPolicy: {
  Always: 0,
  Never: 1,
  OnlyFromMainDocumentDomain: 2,
};

declare const NSPostingStyle: {
  WhenIdle: 1,
  ASAP: 2,
  Now: 3,
};

declare const NSTextCheckingType: {
  Orthography: 1,
  Spelling: 2,
  Grammar: 4,
  Date: 8,
  Address: 16,
  Link: 32,
  Quote: 64,
  Dash: 128,
  Replacement: 256,
  Correction: 512,
};

declare const NSDateFormatterStyle: {
  No: 0,
  Short: 1,
  Medium: 2,
  Long: 3,
  Full: 4,
};

declare const NSKeyValueSetMutationKind: {
  Union: 1,
  Minus: 2,
  Intersect: 3,
  Set: 4,
};

declare const NSNotificationCoalescing: {
  NoCoalescing: 0,
  CoalescingOnName: 1,
  CoalescingOnSender: 2,
};

declare const NSLocaleLanguageDirection: {
  Unknown: 0,
  LeftToRight: 1,
  RightToLeft: 2,
  TopToBottom: 3,
  BottomToTop: 4,
};

declare const NSPredicateOperatorType: {
  LessThan: 0,
  LessThanOrEqualTo: 1,
  GreaterThan: 2,
  GreaterThanOrEqualTo: 3,
  EqualTo: 4,
  NotEqualTo: 5,
  Matches: 6,
  Like: 7,
  BeginsWith: 8,
  EndsWith: 9,
  In: 10,
  CustomSelector: 11,
};

declare const NSFileVersionReplacingOptions: {
  NSFileVersionReplacingByMoving: 1,
};

declare const NSFileVersionAddingOptions: {
  NSFileVersionAddingByMoving: 1,
};

declare const NSXMLParserExternalEntityResolvingPolicy: {
  Never: 0,
  NoNetwork: 1,
  SameOriginOnly: 2,
  Always: 3,
};

declare const NSKeyValueChange: {
  Setting: 1,
  Insertion: 2,
  Removal: 3,
  Replacement: 4,
};

declare const NSExpressionType: {
  ConstantValue: 0,
  EvaluatedObject: 1,
  Variable: 2,
  KeyPath: 3,
  Function: 4,
  Block: 19,
};

declare const NSOperationQueuePriority: {
  VeryLow: -8,
  Low: -4,
  Normal: 0,
  High: 4,
  VeryHigh: 8,
};

declare const NSDateComponentsFormatterUnitsStyle: {
  Positional: 0,
  Abbreviated: 1,
  Short: 2,
  Full: 3,
  SpellOut: 4,
};

declare const NSURLCredentialPersistence: {
  None: 0,
  ForSession: 1,
  Permanent: 2,
};

declare const NSByteCountFormatterCountStyle: {
  File: 0,
  Memory: 1,
  Decimal: 2,
  Binary: 3,
};

declare const NSDataWritingOptions: {
  NSDataWritingAtomic: 1,
};

declare const NSURLRequestNetworkServiceType: {
  Default: 0,
  Video: 2,
  Background: 3,
  Voice: 4,
  ResponsiveData: 6,
};

declare const NSStreamEvent: {
  None: 0,
  OpenCompleted: 1,
  HasBytesAvailable: 2,
  HasSpaceAvailable: 4,
  ErrorOccurred: 8,
  EndEncountered: 16,
};

declare const NSStreamStatus: {
  NotOpen: 0,
  Opening: 1,
  Open: 2,
  Reading: 3,
  Writing: 4,
  AtEnd: 5,
  Closed: 6,
  Error: 7,
};

declare const NSSearchPathDomainMask: {
  UserDomain: 1,
  LocalDomain: 2,
  NetworkDomain: 4,
  SystemDomain: 8,
  AllDomains: 65535,
};

declare const NSSearchPathDirectory: {
  Application: 1,
  DemoApplication: 2,
  DeveloperApplication: 3,
  AdminApplication: 4,
  Library: 5,
  Developer: 6,
  User: 7,
  Documentation: 8,
  Document: 9,
  CoreService: 10,
  Desktop: 12,
  Caches: 13,
  ApplicationSupport: 14,
  AllApplications: 100,
  AllLibraries: 101,
};

declare const NSAttributedStringEnumerationOptions: {
  Reverse: 2,
  LongestEffectiveRangeNotRequired: 1048576,
};

declare const NSNumberFormatterPadPosition: {
  BeforePrefix: 0,
  AfterPrefix: 1,
  BeforeSuffix: 2,
  AfterSuffix: 3,
};

declare const NSNumberFormatterBehavior: {
  BehaviorDefault: 0,
  Behavior10_4: 1040,
};

declare const NSCalendarOptions: {
  NSCalendarWrapComponents: 1,
};

declare const NSCompoundPredicateType: {
  Not: 0,
  And: 1,
  Or: 2,
};

declare const NSComparisonPredicateModifier: {
  Direct: 0,
  All: 1,
  Any: 2,
};

declare const NSDataReadingOptions: {
  MappedIfSafe: 1,
  Uncached: 2,
};

declare const NSBinarySearchingOptions: {
  FirstEqual: 256,
  LastEqual: 512,
  InsertionIndex: 1024,
};

declare const NSEnumerationOptions: {
  Concurrent: 1,
  Reverse: 2,
};

declare const NSCalculationError: {
  NoError: 0,
  LossOfPrecision: 1,
  Underflow: 2,
  Overflow: 3,
  DivideByZero: 4,
};

declare const NSStringEnumerationOptions: {
  ByLines: 0,
  ByParagraphs: 1,
  ByComposedCharacterSequences: 2,
  ByWords: 3,
  BySentences: 4,
  Reverse: 256,
  SubstringNotRequired: 512,
  Localized: 1024,
};

declare const NSMatchingFlags: {
  Progress: 1,
  Completed: 2,
  HitEnd: 4,
  RequiredEnd: 8,
  InternalError: 16,
};

declare const NSPropertyListFormat: {
  OpenStepFormat: 1,
  XMLFormat_v1_0: 100,
  BinaryFormat_v1_0: 200,
};

declare const NSNumberFormatterRoundingMode: {
  Ceiling: 0,
  Floor: 1,
  Down: 2,
  Up: 3,
  HalfEven: 4,
  HalfDown: 5,
  HalfUp: 6,
};

declare const NSCalendarUnit: {
  Era: 2,
  Year: 4,
  Month: 8,
  Day: 16,
  Hour: 32,
  Minute: 64,
  Second: 128,
  Weekday: 512,
  WeekdayOrdinal: 1024,
};

declare const NSRoundingMode: {
  Plain: 0,
  Down: 1,
  Up: 2,
  Bankers: 3,
};

declare const NSFileCoordinatorWritingOptions: {
  Deleting: 1,
  Moving: 2,
  Merging: 4,
  Replacing: 8,
};

declare const NSNumberFormatterStyle: {
  No: 0,
  Decimal: 1,
  Currency: 2,
  Percent: 3,
  Scientific: 4,
  SpellOut: 5,
};

declare const NSComparisonResult: {
  Ascending: -1,
  Same: 0,
  Descending: 1,
};

declare const NSComparisonPredicateOptions: {
  Case: 1,
  Diacritic: 2,
};

declare const NSPropertyListMutabilityOptions: {
  Immutable: 0,
  MutableContainers: 1,
  MutableContainersAndLeaves: 2,
};

declare const NSSortOptions: {
  Concurrent: 1,
  Stable: 16,
};

declare const NSMatchingOptions: {
  ReportProgress: 1,
  ReportCompletion: 2,
  Anchored: 4,
  WithTransparentBounds: 8,
  WithoutAnchoringBounds: 16,
};

declare class NSOperatingSystemVersion {
  constructor(init?: NSOperatingSystemVersion);
  majorVersion: number;
  minorVersion: number;
  patchVersion: number;
}

declare class NSHashEnumerator {
  constructor(init?: NSHashEnumerator);
  _pi: number;
  _si: number;
  _bs: interop.Pointer;
}

declare class NSSwappedDouble {
  constructor(init?: NSSwappedDouble);
  v: number;
}

declare class NSMapTableKeyCallBacks {
  constructor(init?: NSMapTableKeyCallBacks);
  hash: (p1: interop.Object, p2: interop.PointerConvertible) => number | null;
  isEqual: (p1: interop.Object, p2: interop.PointerConvertible, p3: interop.PointerConvertible) => boolean | null;
  retain: (p1: interop.Object, p2: interop.PointerConvertible) => void | null;
  release: (p1: interop.Object, p2: interop.PointerConvertible) => void | null;
  describe: (p1: interop.Object, p2: interop.PointerConvertible) => string | null;
  notAKeyMarker: interop.Pointer;
}

declare class NSMapEnumerator {
  constructor(init?: NSMapEnumerator);
  _pi: number;
  _si: number;
  _bs: interop.Pointer;
}

declare class NSHashTableCallBacks {
  constructor(init?: NSHashTableCallBacks);
  hash: (p1: interop.Object, p2: interop.PointerConvertible) => number | null;
  isEqual: (p1: interop.Object, p2: interop.PointerConvertible, p3: interop.PointerConvertible) => boolean | null;
  retain: (p1: interop.Object, p2: interop.PointerConvertible) => void | null;
  release: (p1: interop.Object, p2: interop.PointerConvertible) => void | null;
  describe: (p1: interop.Object, p2: interop.PointerConvertible) => string | null;
}

declare class NSFastEnumerationState {
  constructor(init?: NSFastEnumerationState);
  state: number;
  itemsPtr: interop.Pointer;
  mutationsPtr: interop.Pointer;
  extra: unknown /* const array */;
}

declare class _NSZone {
  constructor(init?: _NSZone);
}

declare class NSSwappedFloat {
  constructor(init?: NSSwappedFloat);
  v: number;
}

declare class _NSRange {
  constructor(init?: _NSRange);
  location: number;
  length: number;
}

declare class NSMapTableValueCallBacks {
  constructor(init?: NSMapTableValueCallBacks);
  retain: (p1: interop.Object, p2: interop.PointerConvertible) => void | null;
  release: (p1: interop.Object, p2: interop.PointerConvertible) => void | null;
  describe: (p1: interop.Object, p2: interop.PointerConvertible) => string | null;
}

declare class NSDecimal {
  constructor(init?: NSDecimal);
  _exponent: number;
  _length: number;
  _isNegative: number;
  _isCompact: number;
  _reserved: number;
  _mantissa: unknown /* const array */;
}

declare function NSStringFromSelector(aSelector: string): string;

declare function NSSelectorFromString(aSelectorName: string): string;

declare function NSStringFromClass(aClass: interop.Object): string;

declare function NSClassFromString(aClassName: string): interop.Object;

declare function NSGetSizeAndAlignment(typePtr: string, sizep: interop.PointerConvertible, alignp: interop.PointerConvertible): string;

declare function NSLog(format: string): void;

declare function NSLogv(format: string, args: string): void;

declare function NSDefaultMallocZone(): interop.Pointer;

declare function NSCreateZone(startSize: number, granularity: number, canFree: boolean): interop.Pointer;

declare function NSRecycleZone(zone: interop.PointerConvertible): void;

declare function NSSetZoneName(zone: interop.PointerConvertible, name: string): void;

declare function NSZoneName(zone: interop.PointerConvertible): string;

declare function NSZoneFromPointer(ptr: interop.PointerConvertible): interop.Pointer;

declare function NSZoneMalloc(zone: interop.PointerConvertible, size: number): interop.Pointer;

declare function NSZoneCalloc(zone: interop.PointerConvertible, numElems: number, byteSize: number): interop.Pointer;

declare function NSZoneRealloc(zone: interop.PointerConvertible, ptr: interop.PointerConvertible, size: number): interop.Pointer;

declare function NSZoneFree(zone: interop.PointerConvertible, ptr: interop.PointerConvertible): void;

declare function NSPageSize(): number;

declare function NSLogPageSize(): number;

declare function NSRoundUpToMultipleOfPageSize(bytes: number): number;

declare function NSRoundDownToMultipleOfPageSize(bytes: number): number;

declare function NSAllocateMemoryPages(bytes: number): interop.Pointer;

declare function NSDeallocateMemoryPages(ptr: interop.PointerConvertible, bytes: number): void;

declare function NSCopyMemoryPages(source: interop.PointerConvertible, dest: interop.PointerConvertible, bytes: number): void;

declare function NSAllocateObject(aClass: interop.Object, extraBytes: number, zone: interop.PointerConvertible): interop.Object;

declare function NSDeallocateObject(object: interop.Object): void;

declare function NSShouldRetainWithZone(anObject: interop.Object, requestedZone: interop.PointerConvertible): boolean;

declare function NSIncrementExtraRefCount(object: interop.Object): void;

declare function NSDecrementExtraRefCountWasZero(object: interop.Object): boolean;

declare function NSExtraRefCount(object: interop.Object): number;

declare function NSUnionRange(range1: _NSRange, range2: _NSRange): _NSRange;

declare function NSIntersectionRange(range1: _NSRange, range2: _NSRange): _NSRange;

declare function NSStringFromRange(range: _NSRange): string;

declare function NSRangeFromString(aString: string): _NSRange;

declare function NSDecimalCopy(destination: interop.PointerConvertible, source: interop.PointerConvertible): void;

declare function NSDecimalCompact(number: interop.PointerConvertible): void;

declare function NSDecimalCompare(leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible): interop.Enum<typeof NSComparisonResult>;

declare function NSDecimalRound(result: interop.PointerConvertible, number: interop.PointerConvertible, scale: number, roundingMode: interop.Enum<typeof NSRoundingMode>): void;

declare function NSDecimalNormalize(number1: interop.PointerConvertible, number2: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalAdd(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalSubtract(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalMultiply(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalDivide(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalPower(result: interop.PointerConvertible, number: interop.PointerConvertible, power: number, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalMultiplyByPowerOf10(result: interop.PointerConvertible, number: interop.PointerConvertible, power: number, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalString(dcm: interop.PointerConvertible, locale: interop.Object): string;

declare function NSGetUncaughtExceptionHandler(): (p1: NSException) => void;

declare function NSSetUncaughtExceptionHandler(p1: (p1: NSException) => void): void;

declare function NSUserName(): string;

declare function NSFullUserName(): string;

declare function NSHomeDirectory(): string;

declare function NSHomeDirectoryForUser(userName: string): string;

declare function NSTemporaryDirectory(): string;

declare function NSOpenStepRootDirectory(): string;

declare function NSSearchPathForDirectoriesInDomains(directory: interop.Enum<typeof NSSearchPathDirectory>, domainMask: interop.Enum<typeof NSSearchPathDomainMask>, expandTilde: boolean): NSArray;

declare function NSFreeHashTable(table: interop.Object): void;

declare function NSResetHashTable(table: interop.Object): void;

declare function NSCompareHashTables(table1: interop.Object, table2: interop.Object): boolean;

declare function NSCopyHashTableWithZone(table: interop.Object, zone: interop.PointerConvertible): interop.Object;

declare function NSHashGet(table: interop.Object, pointer: interop.PointerConvertible): interop.Pointer;

declare function NSHashInsert(table: interop.Object, pointer: interop.PointerConvertible): void;

declare function NSHashInsertKnownAbsent(table: interop.Object, pointer: interop.PointerConvertible): void;

declare function NSHashInsertIfAbsent(table: interop.Object, pointer: interop.PointerConvertible): interop.Pointer;

declare function NSHashRemove(table: interop.Object, pointer: interop.PointerConvertible): void;

declare function NSEnumerateHashTable(table: interop.Object): NSHashEnumerator;

declare function NSNextHashEnumeratorItem(enumerator: interop.PointerConvertible): interop.Pointer;

declare function NSEndHashTableEnumeration(enumerator: interop.PointerConvertible): void;

declare function NSCountHashTable(table: interop.Object): number;

declare function NSStringFromHashTable(table: interop.Object): string;

declare function NSAllHashTableObjects(table: interop.Object): NSArray;

declare function NSCreateHashTableWithZone(callBacks: NSHashTableCallBacks, capacity: number, zone: interop.PointerConvertible): interop.Object;

declare function NSCreateHashTable(callBacks: NSHashTableCallBacks, capacity: number): interop.Object;

declare function NSFreeMapTable(table: interop.Object): void;

declare function NSResetMapTable(table: interop.Object): void;

declare function NSCompareMapTables(table1: interop.Object, table2: interop.Object): boolean;

declare function NSCopyMapTableWithZone(table: interop.Object, zone: interop.PointerConvertible): interop.Object;

declare function NSMapMember(table: interop.Object, key: interop.PointerConvertible, originalKey: interop.PointerConvertible, value: interop.PointerConvertible): boolean;

declare function NSMapGet(table: interop.Object, key: interop.PointerConvertible): interop.Pointer;

declare function NSMapInsert(table: interop.Object, key: interop.PointerConvertible, value: interop.PointerConvertible): void;

declare function NSMapInsertKnownAbsent(table: interop.Object, key: interop.PointerConvertible, value: interop.PointerConvertible): void;

declare function NSMapInsertIfAbsent(table: interop.Object, key: interop.PointerConvertible, value: interop.PointerConvertible): interop.Pointer;

declare function NSMapRemove(table: interop.Object, key: interop.PointerConvertible): void;

declare function NSEnumerateMapTable(table: interop.Object): NSMapEnumerator;

declare function NSNextMapEnumeratorPair(enumerator: interop.PointerConvertible, key: interop.PointerConvertible, value: interop.PointerConvertible): boolean;

declare function NSEndMapTableEnumeration(enumerator: interop.PointerConvertible): void;

declare function NSCountMapTable(table: interop.Object): number;

declare function NSStringFromMapTable(table: interop.Object): string;

declare function NSAllMapTableKeys(table: interop.Object): NSArray;

declare function NSAllMapTableValues(table: interop.Object): NSArray;

declare function NSCreateMapTableWithZone(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number, zone: interop.PointerConvertible): interop.Object;

declare function NSCreateMapTable(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number): interop.Object;

declare interface NSURLSessionDelegate extends NSObject {
  URLSessionDidBecomeInvalidWithError?(session: interop.Object, error: NSError | null): void;

  URLSessionDidReceiveChallengeCompletionHandler?(session: interop.Object, challenge: interop.Object, completionHandler: (p1: interop.Enum<typeof NSURLSessionAuthChallengeDisposition>, p2: interop.Object) => void | null): void;
}

declare class NSURLSessionDelegate extends NativeObject implements NSURLSessionDelegate {
}

declare interface NSURLSessionTaskDelegate extends NSURLSessionDelegate {
  URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler?(session: interop.Object, task: interop.Object, response: interop.Object, request: interop.Object, completionHandler: (p1: interop.Object) => void | null): void;

  URLSessionTaskDidReceiveChallengeCompletionHandler?(session: interop.Object, task: interop.Object, challenge: interop.Object, completionHandler: (p1: interop.Enum<typeof NSURLSessionAuthChallengeDisposition>, p2: interop.Object) => void | null): void;

  URLSessionTaskNeedNewBodyStream?(session: interop.Object, task: interop.Object, completionHandler: (p1: NSInputStream) => void | null): void;

  URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend?(session: interop.Object, task: interop.Object, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;

  URLSessionTaskDidCompleteWithError?(session: interop.Object, task: interop.Object, error: NSError | null): void;
}

declare class NSURLSessionTaskDelegate extends NativeObject implements NSURLSessionTaskDelegate {
}

declare interface NSLocking {
  lock(): void;

  unlock(): void;
}

declare class NSLocking extends NativeObject implements NSLocking {
}

declare interface NSSecureCoding extends NSCoding {
}

declare class NSSecureCoding extends NativeObject implements NSSecureCoding {
  static readonly supportsSecureCoding: boolean;
}

declare interface NSCopying {
  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSCopying extends NativeObject implements NSCopying {
}

declare interface NSCacheDelegate extends NSObject {
  cacheWillEvictObject?(cache: interop.Object, obj: interop.Object): void;
}

declare class NSCacheDelegate extends NativeObject implements NSCacheDelegate {
}

declare interface NSXPCProxyCreating {
  remoteObjectProxy(): interop.Object;

  remoteObjectProxyWithErrorHandler(handler: (p1: NSError) => void): interop.Object;
}

declare class NSXPCProxyCreating extends NativeObject implements NSXPCProxyCreating {
}

declare interface NSPortDelegate extends NSObject {
  handlePortMessage?(message: interop.Object): void;
}

declare class NSPortDelegate extends NativeObject implements NSPortDelegate {
}

declare interface NSMetadataQueryDelegate extends NSObject {
  metadataQueryReplacementObjectForResultObject?(query: interop.Object, result: interop.Object): interop.Object;

  metadataQueryReplacementValueForAttributeValue?(query: interop.Object, attrName: string, attrValue: interop.Object): interop.Object;
}

declare class NSMetadataQueryDelegate extends NativeObject implements NSMetadataQueryDelegate {
}

declare interface NSMachPortDelegate extends NSPortDelegate {
  handleMachMessage?(msg: interop.PointerConvertible): void;
}

declare class NSMachPortDelegate extends NativeObject implements NSMachPortDelegate {
}

declare interface NSMutableCopying {
  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSMutableCopying extends NativeObject implements NSMutableCopying {
}

declare interface NSFastEnumeration {
  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSFastEnumeration extends NativeObject implements NSFastEnumeration {
}

declare interface NSFilePresenter extends NSObject {
  readonly presentedItemURL: NSURL;

  readonly presentedItemOperationQueue: interop.Object;

  relinquishPresentedItemToReader?(reader: (p1: () => void) => void | null): void;

  relinquishPresentedItemToWriter?(writer: (p1: () => void) => void | null): void;

  savePresentedItemChangesWithCompletionHandler?(completionHandler: (p1: NSError) => void | null): void;

  accommodatePresentedItemDeletionWithCompletionHandler?(completionHandler: (p1: NSError) => void | null): void;

  presentedItemDidMoveToURL?(newURL: NSURL): void;

  presentedItemDidChange?(): void;

  presentedItemDidGainVersion?(version: interop.Object): void;

  presentedItemDidLoseVersion?(version: interop.Object): void;

  presentedItemDidResolveConflictVersion?(version: interop.Object): void;

  accommodatePresentedSubitemDeletionAtURLCompletionHandler?(url: NSURL, completionHandler: (p1: NSError) => void | null): void;

  presentedSubitemDidAppearAtURL?(url: NSURL): void;

  presentedSubitemAtURLDidMoveToURL?(oldURL: NSURL, newURL: NSURL): void;

  presentedSubitemDidChangeAtURL?(url: NSURL): void;

  presentedSubitemAtURLDidGainVersion?(url: NSURL, version: interop.Object): void;

  presentedSubitemAtURLDidLoseVersion?(url: NSURL, version: interop.Object): void;

  presentedSubitemAtURLDidResolveConflictVersion?(url: NSURL, version: interop.Object): void;
}

declare class NSFilePresenter extends NativeObject implements NSFilePresenter {
}

declare interface NSExtensionRequestHandling extends NSObject {
  beginRequestWithExtensionContext(context: interop.Object): void;
}

declare class NSExtensionRequestHandling extends NativeObject implements NSExtensionRequestHandling {
}

declare interface NSXMLParserDelegate extends NSObject {
  parserDidStartDocument?(parser: NSXMLParser): void;

  parserDidEndDocument?(parser: NSXMLParser): void;

  parserFoundNotationDeclarationWithNamePublicIDSystemID?(parser: NSXMLParser, name: string, publicID: string | null, systemID: string | null): void;

  parserFoundUnparsedEntityDeclarationWithNamePublicIDSystemIDNotationName?(parser: NSXMLParser, name: string, publicID: string | null, systemID: string | null, notationName: string | null): void;

  parserFoundAttributeDeclarationWithNameForElementTypeDefaultValue?(parser: NSXMLParser, attributeName: string, elementName: string, type: string | null, defaultValue: string | null): void;

  parserFoundElementDeclarationWithNameModel?(parser: NSXMLParser, elementName: string, model: string): void;

  parserFoundInternalEntityDeclarationWithNameValue?(parser: NSXMLParser, name: string, value: string | null): void;

  parserFoundExternalEntityDeclarationWithNamePublicIDSystemID?(parser: NSXMLParser, name: string, publicID: string | null, systemID: string | null): void;

  parserDidStartElementNamespaceURIQualifiedNameAttributes?(parser: NSXMLParser, elementName: string, namespaceURI: string | null, qName: string | null, attributeDict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  parserDidEndElementNamespaceURIQualifiedName?(parser: NSXMLParser, elementName: string, namespaceURI: string | null, qName: string | null): void;

  parserDidStartMappingPrefixToURI?(parser: NSXMLParser, prefix: string, namespaceURI: string): void;

  parserDidEndMappingPrefix?(parser: NSXMLParser, prefix: string): void;

  parserFoundCharacters?(parser: NSXMLParser, string: string): void;

  parserFoundIgnorableWhitespace?(parser: NSXMLParser, whitespaceString: string): void;

  parserFoundProcessingInstructionWithTargetData?(parser: NSXMLParser, target: string, data: string | null): void;

  parserFoundComment?(parser: NSXMLParser, comment: string): void;

  parserFoundCDATA?(parser: NSXMLParser, CDATABlock: NSData): void;

  parserResolveExternalEntityNameSystemID?(parser: NSXMLParser, name: string, systemID: string | null): NSData;

  parserParseErrorOccurred?(parser: NSXMLParser, parseError: NSError): void;

  parserValidationErrorOccurred?(parser: NSXMLParser, validationError: NSError): void;
}

declare class NSXMLParserDelegate extends NativeObject implements NSXMLParserDelegate {
}

declare interface NSCoding {
  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSCoding extends NativeObject implements NSCoding {
}

declare interface NSDiscardableContent {
  beginContentAccess(): boolean;

  endContentAccess(): void;

  discardContentIfPossible(): void;

  isContentDiscarded(): boolean;
}

declare class NSDiscardableContent extends NativeObject implements NSDiscardableContent {
}

declare interface NSKeyedUnarchiverDelegate extends NSObject {
  unarchiverCannotDecodeObjectOfClassNameOriginalClasses?(unarchiver: NSKeyedUnarchiver, name: string, classNames: NSArray<interop.Object> | Array<interop.Object>): interop.Object;

  unarchiverDidDecodeObject?(unarchiver: NSKeyedUnarchiver, object: interop.Object | null): interop.Object;

  unarchiverWillReplaceObjectWithObject?(unarchiver: NSKeyedUnarchiver, object: interop.Object, newObject: interop.Object): void;

  unarchiverWillFinish?(unarchiver: NSKeyedUnarchiver): void;

  unarchiverDidFinish?(unarchiver: NSKeyedUnarchiver): void;
}

declare class NSKeyedUnarchiverDelegate extends NativeObject implements NSKeyedUnarchiverDelegate {
}

declare interface NSProgressReporting extends NSObject {
  readonly progress: interop.Object;
}

declare class NSProgressReporting extends NativeObject implements NSProgressReporting {
}

declare interface NSDecimalNumberBehaviors {
  roundingMode(): interop.Enum<typeof NSRoundingMode>;

  scale(): number;

  exceptionDuringOperationErrorLeftOperandRightOperand(operation: string, error: interop.Enum<typeof NSCalculationError>, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;
}

declare class NSDecimalNumberBehaviors extends NativeObject implements NSDecimalNumberBehaviors {
}

declare interface NSXPCListenerDelegate extends NSObject {
  listenerShouldAcceptNewConnection?(listener: interop.Object, newConnection: interop.Object): boolean;
}

declare class NSXPCListenerDelegate extends NativeObject implements NSXPCListenerDelegate {
}

declare interface NSStreamDelegate extends NSObject {
  streamHandleEvent?(aStream: NSStream, eventCode: interop.Enum<typeof NSStreamEvent>): void;
}

declare class NSStreamDelegate extends NativeObject implements NSStreamDelegate {
}

declare interface NSKeyedArchiverDelegate extends NSObject {
  archiverWillEncodeObject?(archiver: NSKeyedArchiver, object: interop.Object): interop.Object;

  archiverDidEncodeObject?(archiver: NSKeyedArchiver, object: interop.Object | null): void;

  archiverWillReplaceObjectWithObject?(archiver: NSKeyedArchiver, object: interop.Object | null, newObject: interop.Object | null): void;

  archiverWillFinish?(archiver: NSKeyedArchiver): void;

  archiverDidFinish?(archiver: NSKeyedArchiver): void;
}

declare class NSKeyedArchiverDelegate extends NativeObject implements NSKeyedArchiverDelegate {
}

declare interface NSFileManagerDelegate extends NSObject {
  fileManagerShouldCopyItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;

  fileManagerShouldProceedAfterErrorCopyingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;

  fileManagerShouldMoveItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;

  fileManagerShouldProceedAfterErrorMovingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;

  fileManagerShouldLinkItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;

  fileManagerShouldProceedAfterErrorLinkingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;

  fileManagerShouldRemoveItemAtPath?(fileManager: NSFileManager, path: string): boolean;

  fileManagerShouldProceedAfterErrorRemovingItemAtPath?(fileManager: NSFileManager, error: NSError, path: string): boolean;
}

declare class NSFileManagerDelegate extends NativeObject implements NSFileManagerDelegate {
}

declare class NSSocketPort extends NSPort {
  init(): this;

  initWithTCPPort(port: number): this;

  initWithProtocolFamilySocketTypeProtocolAddress(family: number, type: number, protocol: number, address: NSData): this;

  initWithProtocolFamilySocketTypeProtocolSocket(family: number, type: number, protocol: number, sock: number): this;

  initRemoteWithTCPPortHost(port: number, hostName: string | null): this;

  initRemoteWithProtocolFamilySocketTypeProtocolAddress(family: number, type: number, protocol: number, address: NSData): this;

  readonly protocolFamily: number;

  readonly socketType: number;

  readonly protocol: number;

  readonly address: NSData;

  readonly socket: number;
}

declare class NSNull extends NSObject implements NSCopying, NSSecureCoding {
  static null(): NSNull;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSData extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  readonly length: number;

  readonly bytes: interop.Pointer;

  readonly description: string;

  getBytesLength(buffer: interop.PointerConvertible, length: number): void;

  getBytesRange(buffer: interop.PointerConvertible, range: _NSRange): void;

  isEqualToData(other: NSData): boolean;

  subdataWithRange(range: _NSRange): NSData;

  writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;

  writeToURLAtomically(url: NSURL, atomically: boolean): boolean;

  writeToFileOptionsError(path: string, writeOptionsMask: interop.Enum<typeof NSDataWritingOptions>, errorPtr: interop.PointerConvertible): boolean;

  writeToURLOptionsError(url: NSURL, writeOptionsMask: interop.Enum<typeof NSDataWritingOptions>, errorPtr: interop.PointerConvertible): boolean;

  static data<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dataWithBytesLength<This extends abstract new (...args: any) => any>(this: This, bytes: interop.PointerConvertible, length: number): InstanceType<This>;

  static dataWithBytesNoCopyLength<This extends abstract new (...args: any) => any>(this: This, bytes: interop.PointerConvertible, length: number): InstanceType<This>;

  static dataWithBytesNoCopyLengthFreeWhenDone<This extends abstract new (...args: any) => any>(this: This, bytes: interop.PointerConvertible, length: number, b: boolean): InstanceType<This>;

  static dataWithContentsOfFileOptionsError<This extends abstract new (...args: any) => any>(this: This, path: string, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): InstanceType<This>;

  static dataWithContentsOfURLOptionsError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): InstanceType<This>;

  static dataWithContentsOfFile<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static dataWithContentsOfURL<This extends abstract new (...args: any) => any>(this: This, url: NSURL): InstanceType<This>;

  initWithBytesLength(bytes: interop.PointerConvertible, length: number): this;

  initWithBytesNoCopyLength(bytes: interop.PointerConvertible, length: number): this;

  initWithBytesNoCopyLengthFreeWhenDone(bytes: interop.PointerConvertible, length: number, b: boolean): this;

  initWithContentsOfFileOptionsError(path: string, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): this;

  initWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): this;

  initWithContentsOfFile(path: string): this;

  initWithContentsOfURL(url: NSURL): this;

  initWithData(data: NSData): this;

  static dataWithData<This extends abstract new (...args: any) => any>(this: This, data: NSData): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSCountedSet<ObjectType = interop.Object> extends NSMutableSet {
  initWithCapacity(numItems: number): this;

  initWithArray(array: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithSet(set: NSSet): this;

  countForObject(object: ObjectType): number;

  objectEnumerator(): NSEnumerator;

  addObject(object: ObjectType): void;

  removeObject(object: ObjectType): void;
}

declare class NSPipe extends NSObject {
  readonly fileHandleForReading: NSFileHandle;

  readonly fileHandleForWriting: NSFileHandle;

  static pipe(): NSPipe;
}

declare class NSMethodSignature extends NSObject {
  static signatureWithObjCTypes(types: string): NSMethodSignature;

  readonly numberOfArguments: number;

  getArgumentTypeAtIndex(idx: number): string;

  readonly frameLength: number;

  isOneway(): boolean;

  readonly methodReturnType: string;

  readonly methodReturnLength: number;
}

declare class NSRunLoop extends NSObject {
  static readonly currentRunLoop: NSRunLoop;

  readonly currentMode: string;

  getCFRunLoop(): interop.Pointer;

  addTimerForMode(timer: NSTimer, mode: string): void;

  addPortForMode(aPort: NSPort, mode: string): void;

  removePortForMode(aPort: NSPort, mode: string): void;

  limitDateForMode(mode: string): NSDate;

  acceptInputForModeBeforeDate(mode: string, limitDate: NSDate): void;

  run(): void;

  runUntilDate(limitDate: NSDate): void;

  runModeBeforeDate(mode: string, limitDate: NSDate): boolean;

  performSelectorTargetArgumentOrderModes(aSelector: string, target: interop.Object, arg: interop.Object | null, order: number, modes: NSArray<interop.Object> | Array<interop.Object>): void;

  cancelPerformSelectorTargetArgument(aSelector: string, target: interop.Object, arg: interop.Object | null): void;

  cancelPerformSelectorsWithTarget(target: interop.Object): void;
}

declare class NSNotificationQueue extends NSObject {
  static readonly defaultQueue: NSNotificationQueue;

  initWithNotificationCenter(notificationCenter: NSNotificationCenter): this;

  enqueueNotificationPostingStyle(notification: NSNotification, postingStyle: interop.Enum<typeof NSPostingStyle>): void;

  enqueueNotificationPostingStyleCoalesceMaskForModes(notification: NSNotification, postingStyle: interop.Enum<typeof NSPostingStyle>, coalesceMask: interop.Enum<typeof NSNotificationCoalescing>, modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  dequeueNotificationsMatchingCoalesceMask(notification: NSNotification, coalesceMask: number): void;
}

declare class NSInvocation extends NSObject {
  static invocationWithMethodSignature(sig: NSMethodSignature): NSInvocation;

  readonly methodSignature: NSMethodSignature;

  retainArguments(): void;

  readonly argumentsRetained: boolean;

  target: interop.Object;

  selector: string;

  getReturnValue(retLoc: interop.PointerConvertible): void;

  setReturnValue(retLoc: interop.PointerConvertible): void;

  getArgumentAtIndex(argumentLocation: interop.PointerConvertible, idx: number): void;

  setArgumentAtIndex(argumentLocation: interop.PointerConvertible, idx: number): void;

  invoke(): void;

  invokeWithTarget(target: interop.Object): void;

  invokeUsingIMP(imp: () => void): void;
}

declare class NSNumberFormatter extends NSFormatter {
  getObjectValueForStringRangeError(obj: interop.PointerConvertible, string: string, rangep: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  stringFromNumber(number: NSNumber): string;

  numberFromString(string: string): NSNumber;

  static defaultFormatterBehavior(): interop.Enum<typeof NSNumberFormatterBehavior>;

  static setDefaultFormatterBehavior(behavior: interop.Enum<typeof NSNumberFormatterBehavior>): void;

  minimumGroupingDigits: number;

  numberStyle: interop.Enum<typeof NSNumberFormatterStyle>;

  locale: NSLocale;

  generatesDecimalNumbers: boolean;

  formatterBehavior: interop.Enum<typeof NSNumberFormatterBehavior>;

  negativeFormat: string;

  get textAttributesForNegativeValues(): NSDictionary;
  set textAttributesForNegativeValues(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  positiveFormat: string;

  get textAttributesForPositiveValues(): NSDictionary;
  set textAttributesForPositiveValues(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  allowsFloats: boolean;

  decimalSeparator: string;

  alwaysShowsDecimalSeparator: boolean;

  currencyDecimalSeparator: string;

  usesGroupingSeparator: boolean;

  groupingSeparator: string;

  zeroSymbol: string;

  get textAttributesForZero(): NSDictionary;
  set textAttributesForZero(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  nilSymbol: string;

  get textAttributesForNil(): NSDictionary;
  set textAttributesForNil(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  notANumberSymbol: string;

  get textAttributesForNotANumber(): NSDictionary;
  set textAttributesForNotANumber(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  positiveInfinitySymbol: string;

  get textAttributesForPositiveInfinity(): NSDictionary;
  set textAttributesForPositiveInfinity(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  negativeInfinitySymbol: string;

  get textAttributesForNegativeInfinity(): NSDictionary;
  set textAttributesForNegativeInfinity(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  positivePrefix: string;

  positiveSuffix: string;

  negativePrefix: string;

  negativeSuffix: string;

  currencyCode: string;

  currencySymbol: string;

  internationalCurrencySymbol: string;

  percentSymbol: string;

  perMillSymbol: string;

  minusSign: string;

  plusSign: string;

  exponentSymbol: string;

  groupingSize: number;

  secondaryGroupingSize: number;

  multiplier: NSNumber;

  formatWidth: number;

  paddingCharacter: string;

  paddingPosition: interop.Enum<typeof NSNumberFormatterPadPosition>;

  roundingMode: interop.Enum<typeof NSNumberFormatterRoundingMode>;

  roundingIncrement: NSNumber;

  minimumIntegerDigits: number;

  maximumIntegerDigits: number;

  minimumFractionDigits: number;

  maximumFractionDigits: number;

  minimum: NSNumber;

  maximum: NSNumber;
}

declare class NSNotification extends NSObject implements NSCopying, NSCoding {
  readonly name: string;

  readonly object: interop.Object;

  readonly userInfo: NSDictionary;

  initWithCoder(coder: NSCoder): this;

  static notificationWithNameObject<This extends abstract new (...args: any) => any>(this: This, aName: string, anObject: interop.Object | null): InstanceType<This>;

  static notificationWithNameObjectUserInfo<This extends abstract new (...args: any) => any>(this: This, aName: string, anObject: interop.Object | null, aUserInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  init(): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSCharacterSet extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  static readonly controlCharacterSet: NSCharacterSet;

  static readonly whitespaceCharacterSet: NSCharacterSet;

  static readonly whitespaceAndNewlineCharacterSet: NSCharacterSet;

  static readonly decimalDigitCharacterSet: NSCharacterSet;

  static readonly letterCharacterSet: NSCharacterSet;

  static readonly lowercaseLetterCharacterSet: NSCharacterSet;

  static readonly uppercaseLetterCharacterSet: NSCharacterSet;

  static readonly nonBaseCharacterSet: NSCharacterSet;

  static readonly alphanumericCharacterSet: NSCharacterSet;

  static readonly decomposableCharacterSet: NSCharacterSet;

  static readonly illegalCharacterSet: NSCharacterSet;

  static readonly punctuationCharacterSet: NSCharacterSet;

  static readonly capitalizedLetterCharacterSet: NSCharacterSet;

  static readonly symbolCharacterSet: NSCharacterSet;

  static characterSetWithRange(aRange: _NSRange): NSCharacterSet;

  static characterSetWithCharactersInString(aString: string): NSCharacterSet;

  static characterSetWithBitmapRepresentation(data: NSData): NSCharacterSet;

  static characterSetWithContentsOfFile(fName: string): NSCharacterSet;

  initWithCoder(coder: NSCoder): this;

  characterIsMember(aCharacter: number): boolean;

  readonly bitmapRepresentation: NSData;

  readonly invertedSet: NSCharacterSet;

  longCharacterIsMember(theLongChar: number): boolean;

  isSupersetOfSet(theOtherSet: NSCharacterSet): boolean;

  hasMemberInPlane(thePlane: number): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSIndexSet extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  static indexSet<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static indexSetWithIndex<This extends abstract new (...args: any) => any>(this: This, value: number): InstanceType<This>;

  static indexSetWithIndexesInRange<This extends abstract new (...args: any) => any>(this: This, range: _NSRange): InstanceType<This>;

  initWithIndexesInRange(range: _NSRange): this;

  initWithIndexSet(indexSet: NSIndexSet): this;

  initWithIndex(value: number): this;

  isEqualToIndexSet(indexSet: NSIndexSet): boolean;

  readonly count: number;

  readonly firstIndex: number;

  readonly lastIndex: number;

  indexGreaterThanIndex(value: number): number;

  indexLessThanIndex(value: number): number;

  indexGreaterThanOrEqualToIndex(value: number): number;

  indexLessThanOrEqualToIndex(value: number): number;

  getIndexesMaxCountInIndexRange(indexBuffer: interop.PointerConvertible, bufferSize: number, range: interop.PointerConvertible): number;

  containsIndex(value: number): boolean;

  containsIndexesInRange(range: _NSRange): boolean;

  containsIndexes(indexSet: NSIndexSet): boolean;

  intersectsIndexesInRange(range: _NSRange): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSFileHandle extends NSObject implements NSSecureCoding {
  readonly availableData: NSData;

  initWithFileDescriptorCloseOnDealloc(fd: number, closeopt: boolean): this;

  initWithCoder(coder: NSCoder): this;

  static readonly fileHandleWithStandardInput: NSFileHandle;

  static readonly fileHandleWithStandardOutput: NSFileHandle;

  static readonly fileHandleWithStandardError: NSFileHandle;

  static readonly fileHandleWithNullDevice: NSFileHandle;

  static fileHandleForReadingAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static fileHandleForWritingAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static fileHandleForUpdatingAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  readInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  readInBackgroundAndNotify(): void;

  readToEndOfFileInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  readToEndOfFileInBackgroundAndNotify(): void;

  acceptConnectionInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  acceptConnectionInBackgroundAndNotify(): void;

  waitForDataInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  waitForDataInBackgroundAndNotify(): void;

  initWithFileDescriptor(fd: number): this;

  readonly fileDescriptor: number;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSSortDescriptor extends NSObject implements NSSecureCoding, NSCopying {
  initWithKeyAscending(key: string | null, ascending: boolean): this;

  initWithKeyAscendingSelector(key: string | null, ascending: boolean, selector: string | null): this;

  initWithCoder(coder: NSCoder): this;

  readonly key: string;

  readonly ascending: boolean;

  readonly selector: string;

  compareObjectToObject(object1: interop.Object, object2: interop.Object): interop.Enum<typeof NSComparisonResult>;

  readonly reversedSortDescriptor: interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSMessagePort extends NSPort {
}

declare class NSSimpleCString extends NSString {
}

declare class NSError extends NSObject implements NSCopying, NSSecureCoding {
  initWithDomainCodeUserInfo(domain: string, code: number, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  static errorWithDomainCodeUserInfo<This extends abstract new (...args: any) => any>(this: This, domain: string, code: number, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  readonly domain: string;

  readonly code: number;

  readonly userInfo: NSDictionary;

  readonly localizedDescription: string;

  readonly localizedFailureReason: string;

  readonly localizedRecoverySuggestion: string;

  readonly localizedRecoveryOptions: NSArray;

  readonly recoveryAttempter: interop.Object;

  readonly helpAnchor: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSNumber extends NSValue {
  initWithCoder(coder: NSCoder): this;

  initWithChar(value: number): this;

  initWithUnsignedChar(value: number): this;

  initWithShort(value: number): this;

  initWithUnsignedShort(value: number): this;

  initWithInt(value: number): this;

  initWithUnsignedInt(value: number): this;

  initWithLong(value: number): this;

  initWithUnsignedLong(value: number): this;

  initWithLongLong(value: number): this;

  initWithUnsignedLongLong(value: number): this;

  initWithFloat(value: number): this;

  initWithDouble(value: number): this;

  initWithBool(value: boolean): this;

  readonly charValue: number;

  readonly unsignedCharValue: number;

  readonly shortValue: number;

  readonly unsignedShortValue: number;

  readonly intValue: number;

  readonly unsignedIntValue: number;

  readonly longValue: number;

  readonly unsignedLongValue: number;

  readonly longLongValue: number;

  readonly unsignedLongLongValue: number;

  readonly floatValue: number;

  readonly doubleValue: number;

  readonly boolValue: boolean;

  readonly stringValue: string;

  compare(otherNumber: NSNumber): interop.Enum<typeof NSComparisonResult>;

  isEqualToNumber(number: NSNumber): boolean;

  descriptionWithLocale(locale: interop.Object | null): string;

  static numberWithChar(value: number): NSNumber;

  static numberWithUnsignedChar(value: number): NSNumber;

  static numberWithShort(value: number): NSNumber;

  static numberWithUnsignedShort(value: number): NSNumber;

  static numberWithInt(value: number): NSNumber;

  static numberWithUnsignedInt(value: number): NSNumber;

  static numberWithLong(value: number): NSNumber;

  static numberWithUnsignedLong(value: number): NSNumber;

  static numberWithLongLong(value: number): NSNumber;

  static numberWithUnsignedLongLong(value: number): NSNumber;

  static numberWithFloat(value: number): NSNumber;

  static numberWithDouble(value: number): NSNumber;

  static numberWithBool(value: boolean): NSNumber;

  readonly decimalValue: NSDecimal;
}

declare class NSAutoreleasePool extends NSObject {
  static addObject(anObject: interop.Object): void;

  addObject(anObject: interop.Object): void;

  drain(): void;
}

declare class NSMutableSet<ObjectType = interop.Object> extends NSSet {
  addObject(object: ObjectType): void;

  removeObject(object: ObjectType): void;

  initWithCoder(coder: NSCoder): this;

  init(): this;

  initWithCapacity(numItems: number): this;

  addObjectsFromArray(array: NSArray<interop.Object> | Array<interop.Object>): void;

  intersectSet(otherSet: NSSet): void;

  minusSet(otherSet: NSSet): void;

  removeAllObjects(): void;

  unionSet(otherSet: NSSet): void;

  setSet(otherSet: NSSet): void;

  static setWithCapacity<ObjectType, This extends abstract new (...args: any) => any>(this: This, numItems: number): InstanceType<This>;
}

declare class NSConditionLock extends NSObject implements NSLocking {
  initWithCondition(condition: number): this;

  readonly condition: number;

  lockWhenCondition(condition: number): void;

  tryLock(): boolean;

  tryLockWhenCondition(condition: number): boolean;

  unlockWithCondition(condition: number): void;

  lockBeforeDate(limit: NSDate): boolean;

  lockWhenConditionBeforeDate(condition: number, limit: NSDate): boolean;

  lock(): void;

  unlock(): void;
}

declare class NSArray<ObjectType = interop.Object> extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
  readonly count: number;

  objectAtIndex(index: number): ObjectType;

  init(): this;

  initWithObjectsCount(objects: interop.PointerConvertible, cnt: number): this;

  initWithCoder(coder: NSCoder): this;

  arrayByAddingObject(anObject: ObjectType): NSArray;

  arrayByAddingObjectsFromArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  componentsJoinedByString(separator: string): string;

  containsObject(anObject: ObjectType): boolean;

  readonly description: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  descriptionWithLocaleIndent(locale: interop.Object | null, level: number): string;

  firstObjectCommonWithArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): ObjectType;

  getObjectsRange(objects: interop.PointerConvertible, range: _NSRange): void;

  indexOfObject(anObject: ObjectType): number;

  indexOfObjectInRange(anObject: ObjectType, range: _NSRange): number;

  indexOfObjectIdenticalTo(anObject: ObjectType): number;

  indexOfObjectIdenticalToInRange(anObject: ObjectType, range: _NSRange): number;

  isEqualToArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): boolean;

  readonly lastObject: ObjectType;

  objectEnumerator(): NSEnumerator;

  reverseObjectEnumerator(): NSEnumerator;

  readonly sortedArrayHint: NSData;

  sortedArrayUsingFunctionContext(comparator: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => number | null, context: interop.PointerConvertible): NSArray;

  sortedArrayUsingFunctionContextHint(comparator: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => number | null, context: interop.PointerConvertible, hint: NSData | null): NSArray;

  sortedArrayUsingSelector(comparator: string): NSArray;

  subarrayWithRange(range: _NSRange): NSArray;

  makeObjectsPerformSelector(aSelector: string): void;

  makeObjectsPerformSelectorWithObject(aSelector: string, argument: interop.Object | null): void;

  objectsAtIndexes(indexes: NSIndexSet): NSArray;

  static array<ObjectType, This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static arrayWithObject<ObjectType, This extends abstract new (...args: any) => any>(this: This, anObject: ObjectType): InstanceType<This>;

  static arrayWithObjectsCount<ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: interop.PointerConvertible, cnt: number): InstanceType<This>;

  static arrayWithObjects<ObjectType, This extends abstract new (...args: any) => any>(this: This, firstObj: ObjectType): InstanceType<This>;

  static arrayWithArray<ObjectType, This extends abstract new (...args: any) => any>(this: This, array: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithObjects(firstObj: ObjectType): this;

  initWithArray(array: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithArrayCopyItems(array: NSArray<interop.Object> | Array<interop.Object>, flag: boolean): this;

  pathsMatchingExtensions(filterTypes: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  valueForKey(key: string): interop.Object;

  setValueForKey(value: interop.Object | null, key: string): void;

  addObserverToObjectsAtIndexesForKeyPathOptionsContext(observer: interop.Object, indexes: NSIndexSet, keyPath: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  removeObserverFromObjectsAtIndexesForKeyPath(observer: interop.Object, indexes: NSIndexSet, keyPath: string): void;

  addObserverForKeyPathOptionsContext(observer: interop.Object, keyPath: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  removeObserverForKeyPath(observer: interop.Object, keyPath: string): void;

  sortedArrayUsingDescriptors(sortDescriptors: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  filteredArrayUsingPredicate(predicate: interop.Object): NSArray;

  shuffledArrayWithRandomSource(randomSource: interop.Object): NSArray;

  shuffledArray(): NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  readonly [Symbol.iterator]: () => Iterator<ObjectType>;

}

declare class NSString extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  readonly length: number;

  characterAtIndex(index: number): number;

  init(): this;

  initWithCoder(coder: NSCoder): this;

  substringFromIndex(from: number): string;

  substringToIndex(to: number): string;

  substringWithRange(range: _NSRange): string;

  getCharactersRange(buffer: interop.PointerConvertible, range: _NSRange): void;

  compare(string: string): interop.Enum<typeof NSComparisonResult>;

  compareOptions(string: string, mask: interop.Enum<typeof NSStringCompareOptions>): interop.Enum<typeof NSComparisonResult>;

  compareOptionsRange(string: string, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToCompare: _NSRange): interop.Enum<typeof NSComparisonResult>;

  compareOptionsRangeLocale(string: string, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToCompare: _NSRange, locale: interop.Object | null): interop.Enum<typeof NSComparisonResult>;

  caseInsensitiveCompare(string: string): interop.Enum<typeof NSComparisonResult>;

  localizedCompare(string: string): interop.Enum<typeof NSComparisonResult>;

  localizedCaseInsensitiveCompare(string: string): interop.Enum<typeof NSComparisonResult>;

  isEqualToString(aString: string): boolean;

  hasPrefix(str: string): boolean;

  hasSuffix(str: string): boolean;

  commonPrefixWithStringOptions(str: string, mask: interop.Enum<typeof NSStringCompareOptions>): string;

  rangeOfString(searchString: string): _NSRange;

  rangeOfStringOptions(searchString: string, mask: interop.Enum<typeof NSStringCompareOptions>): _NSRange;

  rangeOfStringOptionsRange(searchString: string, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToSearch: _NSRange): _NSRange;

  rangeOfCharacterFromSet(searchSet: NSCharacterSet): _NSRange;

  rangeOfCharacterFromSetOptions(searchSet: NSCharacterSet, mask: interop.Enum<typeof NSStringCompareOptions>): _NSRange;

  rangeOfCharacterFromSetOptionsRange(searchSet: NSCharacterSet, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToSearch: _NSRange): _NSRange;

  rangeOfComposedCharacterSequenceAtIndex(index: number): _NSRange;

  stringByAppendingString(aString: string): string;

  stringByAppendingFormat(format: string): string;

  readonly doubleValue: number;

  readonly floatValue: number;

  readonly intValue: number;

  readonly uppercaseString: string;

  readonly lowercaseString: string;

  readonly capitalizedString: string;

  getLineStartEndContentsEndForRange(startPtr: interop.PointerConvertible, lineEndPtr: interop.PointerConvertible, contentsEndPtr: interop.PointerConvertible, range: _NSRange): void;

  lineRangeForRange(range: _NSRange): _NSRange;

  getParagraphStartEndContentsEndForRange(startPtr: interop.PointerConvertible, parEndPtr: interop.PointerConvertible, contentsEndPtr: interop.PointerConvertible, range: _NSRange): void;

  paragraphRangeForRange(range: _NSRange): _NSRange;

  readonly UTF8String: string;

  readonly fastestEncoding: number;

  readonly smallestEncoding: number;

  dataUsingEncodingAllowLossyConversion(encoding: number, lossy: boolean): NSData;

  dataUsingEncoding(encoding: number): NSData;

  canBeConvertedToEncoding(encoding: number): boolean;

  cStringUsingEncoding(encoding: number): string;

  getCStringMaxLengthEncoding(buffer: string, maxBufferCount: number, encoding: number): boolean;

  getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange(buffer: interop.PointerConvertible, maxBufferCount: number, usedBufferCount: interop.PointerConvertible, encoding: number, options: interop.Enum<typeof NSStringEncodingConversionOptions>, range: _NSRange, leftover: interop.PointerConvertible): boolean;

  maximumLengthOfBytesUsingEncoding(enc: number): number;

  lengthOfBytesUsingEncoding(enc: number): number;

  static readonly availableStringEncodings: interop.Pointer;

  static localizedNameOfStringEncoding(encoding: number): string;

  static readonly defaultCStringEncoding: number;

  readonly decomposedStringWithCanonicalMapping: string;

  readonly precomposedStringWithCanonicalMapping: string;

  readonly decomposedStringWithCompatibilityMapping: string;

  readonly precomposedStringWithCompatibilityMapping: string;

  componentsSeparatedByString(separator: string): NSArray;

  stringByTrimmingCharactersInSet(set: NSCharacterSet): string;

  stringByPaddingToLengthWithStringStartingAtIndex(newLength: number, padString: string, padIndex: number): string;

  writeToURLAtomicallyEncodingError(url: NSURL, useAuxiliaryFile: boolean, enc: number, error: interop.PointerConvertible): boolean;

  writeToFileAtomicallyEncodingError(path: string, useAuxiliaryFile: boolean, enc: number, error: interop.PointerConvertible): boolean;

  readonly description: string;

  readonly hash: number;

  initWithCharactersNoCopyLengthFreeWhenDone(characters: interop.PointerConvertible, length: number, freeBuffer: boolean): this;

  initWithCharactersNoCopyLengthDeallocator(chars: interop.PointerConvertible, len: number, deallocator: (p1: interop.PointerConvertible, p2: number) => void | null): this;

  initWithCharactersLength(characters: interop.PointerConvertible, length: number): this;

  initWithUTF8String(nullTerminatedCString: string): this;

  initWithString(aString: string): this;

  initWithFormat(format: string): this;

  initWithFormatArguments(format: string, argList: string): this;

  initWithFormatLocale(format: string, locale: interop.Object | null): this;

  initWithFormatLocaleArguments(format: string, locale: interop.Object | null, argList: string): this;

  initWithDataEncoding(data: NSData, encoding: number): this;

  initWithBytesLengthEncoding(bytes: interop.PointerConvertible, len: number, encoding: number): this;

  initWithBytesNoCopyLengthEncodingFreeWhenDone(bytes: interop.PointerConvertible, len: number, encoding: number, freeBuffer: boolean): this;

  initWithBytesNoCopyLengthEncodingDeallocator(bytes: interop.PointerConvertible, len: number, encoding: number, deallocator: (p1: interop.PointerConvertible, p2: number) => void | null): this;

  static string<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static stringWithString<This extends abstract new (...args: any) => any>(this: This, string: string): InstanceType<This>;

  static stringWithCharactersLength<This extends abstract new (...args: any) => any>(this: This, characters: interop.PointerConvertible, length: number): InstanceType<This>;

  static stringWithUTF8String<This extends abstract new (...args: any) => any>(this: This, nullTerminatedCString: string): InstanceType<This>;

  static stringWithFormat<This extends abstract new (...args: any) => any>(this: This, format: string): InstanceType<This>;

  static localizedStringWithFormat<This extends abstract new (...args: any) => any>(this: This, format: string): InstanceType<This>;

  initWithCStringEncoding(nullTerminatedCString: string, encoding: number): this;

  static stringWithCStringEncoding<This extends abstract new (...args: any) => any>(this: This, cString: string, enc: number): InstanceType<This>;

  initWithContentsOfURLEncodingError(url: NSURL, enc: number, error: interop.PointerConvertible): this;

  initWithContentsOfFileEncodingError(path: string, enc: number, error: interop.PointerConvertible): this;

  static stringWithContentsOfURLEncodingError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, enc: number, error: interop.PointerConvertible): InstanceType<This>;

  static stringWithContentsOfFileEncodingError<This extends abstract new (...args: any) => any>(this: This, path: string, enc: number, error: interop.PointerConvertible): InstanceType<This>;

  initWithContentsOfURLUsedEncodingError(url: NSURL, enc: interop.PointerConvertible, error: interop.PointerConvertible): this;

  initWithContentsOfFileUsedEncodingError(path: string, enc: interop.PointerConvertible, error: interop.PointerConvertible): this;

  static stringWithContentsOfURLUsedEncodingError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, enc: interop.PointerConvertible, error: interop.PointerConvertible): InstanceType<This>;

  static stringWithContentsOfFileUsedEncodingError<This extends abstract new (...args: any) => any>(this: This, path: string, enc: interop.PointerConvertible, error: interop.PointerConvertible): InstanceType<This>;

  propertyList(): interop.Object;

  propertyListFromStringsFileFormat(): NSDictionary;

  getCharacters(buffer: interop.PointerConvertible): void;

  static pathWithComponents(components: NSArray<interop.Object> | Array<interop.Object>): string;

  readonly pathComponents: NSArray;

  readonly isAbsolutePath: boolean;

  readonly lastPathComponent: string;

  readonly stringByDeletingLastPathComponent: string;

  stringByAppendingPathComponent(str: string): string;

  readonly pathExtension: string;

  readonly stringByDeletingPathExtension: string;

  stringByAppendingPathExtension(str: string): string;

  readonly stringByAbbreviatingWithTildeInPath: string;

  readonly stringByExpandingTildeInPath: string;

  readonly stringByStandardizingPath: string;

  readonly stringByResolvingSymlinksInPath: string;

  stringsByAppendingPaths(paths: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes(outputName: interop.PointerConvertible, flag: boolean, outputArray: interop.PointerConvertible, filterTypes: NSArray<interop.Object> | Array<interop.Object> | null): number;

  readonly fileSystemRepresentation: string;

  getFileSystemRepresentationMaxLength(cname: string, max: number): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSInputStream extends NSStream {
  readMaxLength(buffer: interop.PointerConvertible, len: number): number;

  getBufferLength(buffer: interop.PointerConvertible, len: interop.PointerConvertible): boolean;

  readonly hasBytesAvailable: boolean;

  initWithData(data: NSData): this;

  initWithFileAtPath(path: string): this;

  static inputStreamWithData<This extends abstract new (...args: any) => any>(this: This, data: NSData): InstanceType<This>;

  static inputStreamWithFileAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;
}

declare class NSProxy extends NativeObject implements NSObject {
  static alloc<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static allocWithZone<This extends abstract new (...args: any) => any>(this: This, zone: interop.PointerConvertible): InstanceType<This>;

  static class(): interop.Object;

  forwardInvocation(invocation: NSInvocation): void;

  methodSignatureForSelector(sel: string): NSMethodSignature;

  dealloc(): void;

  finalize(): void;

  readonly description: string;

  readonly debugDescription: string;

  static respondsToSelector(aSelector: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  isProxy(): boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  zone(): interop.Pointer;
}

declare class NSTimeZone extends NSObject implements NSCopying, NSSecureCoding {
  readonly name: string;

  readonly data: NSData;

  secondsFromGMTForDate(aDate: NSDate): number;

  abbreviationForDate(aDate: NSDate): string;

  isDaylightSavingTimeForDate(aDate: NSDate): boolean;

  static readonly systemTimeZone: NSTimeZone;

  static resetSystemTimeZone(): void;

  static defaultTimeZone: NSTimeZone;

  static readonly localTimeZone: NSTimeZone;

  static readonly knownTimeZoneNames: NSArray;

  static abbreviationDictionary(): NSDictionary;

  readonly secondsFromGMT: number;

  readonly abbreviation: string;

  readonly isDaylightSavingTime: boolean;

  readonly description: string;

  isEqualToTimeZone(aTimeZone: NSTimeZone): boolean;

  static timeZoneWithName<This extends abstract new (...args: any) => any>(this: This, tzName: string): InstanceType<This>;

  static timeZoneWithNameData<This extends abstract new (...args: any) => any>(this: This, tzName: string, aData: NSData | null): InstanceType<This>;

  initWithName(tzName: string): this;

  initWithNameData(tzName: string, aData: NSData | null): this;

  static timeZoneForSecondsFromGMT<This extends abstract new (...args: any) => any>(this: This, seconds: number): InstanceType<This>;

  static timeZoneWithAbbreviation<This extends abstract new (...args: any) => any>(this: This, abbreviation: string): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSMutableData extends NSData {
  readonly mutableBytes: interop.Pointer;

  // @ts-ignore MemberDecl.tsIgnore
  length: number;

  appendBytesLength(bytes: interop.PointerConvertible, length: number): void;

  appendData(other: NSData): void;

  increaseLengthBy(extraLength: number): void;

  replaceBytesInRangeWithBytes(range: _NSRange, bytes: interop.PointerConvertible): void;

  resetBytesInRange(range: _NSRange): void;

  setData(data: NSData): void;

  replaceBytesInRangeWithBytesLength(range: _NSRange, replacementBytes: interop.PointerConvertible, replacementLength: number): void;

  static dataWithCapacity<This extends abstract new (...args: any) => any>(this: This, aNumItems: number): InstanceType<This>;

  static dataWithLength<This extends abstract new (...args: any) => any>(this: This, length: number): InstanceType<This>;

  initWithCapacity(capacity: number): this;

  initWithLength(length: number): this;
}

declare class NSOutputStream extends NSStream {
  writeMaxLength(buffer: interop.PointerConvertible, len: number): number;

  readonly hasSpaceAvailable: boolean;

  initToMemory(): this;

  initToBufferCapacity(buffer: interop.PointerConvertible, capacity: number): this;

  initToFileAtPathAppend(path: string, shouldAppend: boolean): this;

  static outputStreamToMemory<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static outputStreamToBufferCapacity<This extends abstract new (...args: any) => any>(this: This, buffer: interop.PointerConvertible, capacity: number): InstanceType<This>;

  static outputStreamToFileAtPathAppend<This extends abstract new (...args: any) => any>(this: This, path: string, shouldAppend: boolean): InstanceType<This>;
}

declare class NSTimer extends NSObject {
  static timerWithTimeIntervalInvocationRepeats(ti: number, invocation: NSInvocation, yesOrNo: boolean): NSTimer;

  static scheduledTimerWithTimeIntervalInvocationRepeats(ti: number, invocation: NSInvocation, yesOrNo: boolean): NSTimer;

  static timerWithTimeIntervalTargetSelectorUserInfoRepeats(ti: number, aTarget: interop.Object, aSelector: string, userInfo: interop.Object | null, yesOrNo: boolean): NSTimer;

  static scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(ti: number, aTarget: interop.Object, aSelector: string, userInfo: interop.Object | null, yesOrNo: boolean): NSTimer;

  initWithFireDateIntervalTargetSelectorUserInfoRepeats(date: NSDate, ti: number, t: interop.Object, s: string, ui: interop.Object | null, rep: boolean): this;

  fire(): void;

  fireDate: NSDate;

  readonly timeInterval: number;

  invalidate(): void;

  readonly isValid: boolean;

  readonly userInfo: interop.Object;
}

declare class NSProcessInfo extends NSObject {
  static readonly processInfo: NSProcessInfo;

  readonly environment: NSDictionary;

  readonly arguments: NSArray;

  readonly hostName: string;

  processName: string;

  readonly processIdentifier: number;

  readonly globallyUniqueString: string;

  readonly operatingSystemVersionString: string;
}

declare class NSDirectoryEnumerator<ObjectType = interop.Object> extends NSEnumerator {
  readonly fileAttributes: NSDictionary;

  readonly directoryAttributes: NSDictionary;

  skipDescendents(): void;
}

declare class NSStream extends NSObject {
  open(): void;

  close(): void;

  delegate: NSStreamDelegate;

  propertyForKey(key: string): interop.Object;

  setPropertyForKey(property: interop.Object | null, key: string): boolean;

  scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  readonly streamStatus: interop.Enum<typeof NSStreamStatus>;

  readonly streamError: NSError;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSMachPort extends NSPort {
  static portWithMachPort(machPort: number): NSPort;

  initWithMachPort(machPort: number): this;

  // @ts-ignore MemberDecl.tsIgnore
  setDelegate(anObject: NSMachPortDelegate | null): void;

  // @ts-ignore MemberDecl.tsIgnore
  delegate(): NSMachPortDelegate;

  readonly machPort: number;

  scheduleInRunLoopForMode(runLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(runLoop: NSRunLoop, mode: string): void;
}

declare class NSKeyedArchiver extends NSCoder {
  delegate: NSKeyedArchiverDelegate;

  outputFormat: interop.Enum<typeof NSPropertyListFormat>;

  finishEncoding(): void;

  static setClassNameForClass(codedName: string | null, cls: interop.Object): void;

  setClassNameForClass(codedName: string | null, cls: interop.Object): void;

  static classNameForClass(cls: interop.Object): string;

  classNameForClass(cls: interop.Object): string;

  encodeObjectForKey(object: interop.Object | null, key: string): void;

  encodeConditionalObjectForKey(object: interop.Object | null, key: string): void;

  encodeBoolForKey(value: boolean, key: string): void;

  encodeIntForKey(value: number, key: string): void;

  encodeInt32ForKey(value: number, key: string): void;

  encodeInt64ForKey(value: number, key: string): void;

  encodeFloatForKey(value: number, key: string): void;

  encodeDoubleForKey(value: number, key: string): void;

  encodeBytesLengthForKey(bytes: interop.PointerConvertible, length: number, key: string): void;
}

declare class NSPort extends NSObject implements NSCopying, NSCoding {
  static port(): NSPort;

  invalidate(): void;

  readonly isValid: boolean;

  setDelegate(anObject: NSPortDelegate | null): void;

  delegate(): NSPortDelegate;

  scheduleInRunLoopForMode(runLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(runLoop: NSRunLoop, mode: string): void;

  readonly reservedSpaceLength: number;

  sendBeforeDateComponentsFromReserved(limitDate: NSDate, components: NSMutableArray | null, receivePort: NSPort | null, headerSpaceReserved: number): boolean;

  sendBeforeDateMsgidComponentsFromReserved(limitDate: NSDate, msgID: number, components: NSMutableArray | null, receivePort: NSPort | null, headerSpaceReserved: number): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSDecimalNumber extends NSNumber {
  initWithMantissaExponentIsNegative(mantissa: number, exponent: number, flag: boolean): this;

  initWithDecimal(dcm: NSDecimal): this;

  initWithString(numberValue: string | null): this;

  initWithStringLocale(numberValue: string | null, locale: interop.Object | null): this;

  descriptionWithLocale(locale: interop.Object | null): string;

  readonly decimalValue: NSDecimal;

  static decimalNumberWithMantissaExponentIsNegative(mantissa: number, exponent: number, flag: boolean): NSDecimalNumber;

  static decimalNumberWithDecimal(dcm: NSDecimal): NSDecimalNumber;

  static decimalNumberWithString(numberValue: string | null): NSDecimalNumber;

  static decimalNumberWithStringLocale(numberValue: string | null, locale: interop.Object | null): NSDecimalNumber;

  static readonly zero: NSDecimalNumber;

  static readonly one: NSDecimalNumber;

  static readonly minimumDecimalNumber: NSDecimalNumber;

  static readonly maximumDecimalNumber: NSDecimalNumber;

  static readonly notANumber: NSDecimalNumber;

  decimalNumberByAdding(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberByAddingWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberBySubtracting(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberBySubtractingWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByMultiplyingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberByMultiplyingByWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByDividingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberByDividingByWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByRaisingToPower(power: number): NSDecimalNumber;

  decimalNumberByRaisingToPowerWithBehavior(power: number, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByMultiplyingByPowerOf10(power: number): NSDecimalNumber;

  decimalNumberByMultiplyingByPowerOf10WithBehavior(power: number, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByRoundingAccordingToBehavior(behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  // @ts-ignore MemberDecl.tsIgnore
  compare(decimalNumber: NSNumber): interop.Enum<typeof NSComparisonResult>;

  static defaultBehavior: NSDecimalNumberBehaviors;

  readonly objCType: string;

  readonly doubleValue: number;
}

declare class NSException extends NSObject implements NSCopying, NSSecureCoding {
  static exceptionWithNameReasonUserInfo(name: string, reason: string | null, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSException;

  initWithNameReasonUserInfo(aName: string, aReason: string | null, aUserInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  readonly name: string;

  readonly reason: string;

  readonly userInfo: NSDictionary;

  raise(): void;

  static raiseFormat(name: string, format: string): void;

  static raiseFormatArguments(name: string, format: string, argList: string): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSLock extends NSObject implements NSLocking {
  tryLock(): boolean;

  lockBeforeDate(limit: NSDate): boolean;

  lock(): void;

  unlock(): void;
}

declare class NSKeyValueSharedObserversSnapshot extends NSObject {
}

declare class NSKeyedUnarchiver extends NSCoder {
  delegate: NSKeyedUnarchiverDelegate;

  finishDecoding(): void;

  static setClassForClassName(cls: interop.Object | null, codedName: string): void;

  setClassForClassName(cls: interop.Object | null, codedName: string): void;

  static classForClassName(codedName: string): interop.Object;

  classForClassName(codedName: string): interop.Object;

  containsValueForKey(key: string): boolean;

  decodeObjectForKey(key: string): interop.Object;

  decodeBoolForKey(key: string): boolean;

  decodeIntForKey(key: string): number;

  decodeInt32ForKey(key: string): number;

  decodeInt64ForKey(key: string): number;

  decodeFloatForKey(key: string): number;

  decodeDoubleForKey(key: string): number;

  decodeBytesForKeyReturnedLength(key: string, lengthp: interop.PointerConvertible): interop.Pointer;
}

declare class NSUserDefaults extends NSObject {
  static readonly standardUserDefaults: NSUserDefaults;

  static resetStandardUserDefaults(): void;

  init(): this;

  objectForKey(defaultName: string): interop.Object;

  setObjectForKey(value: interop.Object | null, defaultName: string): void;

  removeObjectForKey(defaultName: string): void;

  stringForKey(defaultName: string): string;

  arrayForKey(defaultName: string): NSArray;

  dictionaryForKey(defaultName: string): NSDictionary;

  dataForKey(defaultName: string): NSData;

  stringArrayForKey(defaultName: string): NSArray;

  integerForKey(defaultName: string): number;

  floatForKey(defaultName: string): number;

  doubleForKey(defaultName: string): number;

  boolForKey(defaultName: string): boolean;

  setIntegerForKey(value: number, defaultName: string): void;

  setFloatForKey(value: number, defaultName: string): void;

  setDoubleForKey(value: number, defaultName: string): void;

  setBoolForKey(value: boolean, defaultName: string): void;

  registerDefaults(registrationDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  addSuiteNamed(suiteName: string): void;

  removeSuiteNamed(suiteName: string): void;

  dictionaryRepresentation(): NSDictionary;

  readonly volatileDomainNames: NSArray;

  volatileDomainForName(domainName: string): NSDictionary;

  setVolatileDomainForName(domain: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, domainName: string): void;

  removeVolatileDomainForName(domainName: string): void;

  persistentDomainForName(domainName: string): NSDictionary;

  setPersistentDomainForName(domain: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, domainName: string): void;

  removePersistentDomainForName(domainName: string): void;

  synchronize(): boolean;

  objectIsForcedForKey(key: string): boolean;

  objectIsForcedForKeyInDomain(key: string, domain: string): boolean;
}

declare class NSPropertyListSerialization extends NSObject {
  static propertyListIsValidForFormat(plist: interop.Object, format: interop.Enum<typeof NSPropertyListFormat>): boolean;
}

declare class NSIndexPath extends NSObject implements NSCopying, NSSecureCoding {
  static indexPathWithIndex<This extends abstract new (...args: any) => any>(this: This, index: number): InstanceType<This>;

  static indexPathWithIndexesLength<This extends abstract new (...args: any) => any>(this: This, indexes: interop.PointerConvertible, length: number): InstanceType<This>;

  initWithIndexesLength(indexes: interop.PointerConvertible, length: number): this;

  initWithIndex(index: number): this;

  indexPathByAddingIndex(index: number): NSIndexPath;

  indexPathByRemovingLastIndex(): NSIndexPath;

  indexAtPosition(position: number): number;

  readonly length: number;

  compare(otherObject: NSIndexPath): interop.Enum<typeof NSComparisonResult>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSSet<ObjectType = interop.Object> extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
  readonly count: number;

  member(object: ObjectType): ObjectType;

  objectEnumerator(): NSEnumerator;

  init(): this;

  initWithObjectsCount(objects: interop.PointerConvertible, cnt: number): this;

  initWithCoder(coder: NSCoder): this;

  readonly allObjects: NSArray;

  anyObject(): ObjectType;

  containsObject(anObject: ObjectType): boolean;

  readonly description: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  intersectsSet(otherSet: NSSet): boolean;

  isEqualToSet(otherSet: NSSet): boolean;

  isSubsetOfSet(otherSet: NSSet): boolean;

  makeObjectsPerformSelector(aSelector: string): void;

  makeObjectsPerformSelectorWithObject(aSelector: string, argument: interop.Object | null): void;

  static set<ObjectType, This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static setWithObject<ObjectType, This extends abstract new (...args: any) => any>(this: This, object: ObjectType): InstanceType<This>;

  static setWithObjectsCount<ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: interop.PointerConvertible, cnt: number): InstanceType<This>;

  static setWithObjects<ObjectType, This extends abstract new (...args: any) => any>(this: This, firstObj: ObjectType): InstanceType<This>;

  static setWithSet<ObjectType, This extends abstract new (...args: any) => any>(this: This, set: NSSet): InstanceType<This>;

  static setWithArray<ObjectType, This extends abstract new (...args: any) => any>(this: This, array: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithObjects(firstObj: ObjectType): this;

  initWithSet(set: NSSet): this;

  initWithSetCopyItems(set: NSSet, flag: boolean): this;

  initWithArray(array: NSArray<interop.Object> | Array<interop.Object>): this;

  valueForKey(key: string): interop.Object;

  setValueForKey(value: interop.Object | null, key: string): void;

  addObserverForKeyPathOptionsContext(observer: interop.Object, keyPath: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  removeObserverForKeyPath(observer: interop.Object, keyPath: string): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  readonly [Symbol.iterator]: () => Iterator<ObjectType>;

}

declare class NSFileManager extends NSObject {
  static readonly defaultManager: NSFileManager;

  readonly currentDirectoryPath: string;

  changeCurrentDirectoryPath(path: string): boolean;

  fileExistsAtPath(path: string): boolean;

  fileExistsAtPathIsDirectory(path: string, isDirectory: interop.PointerConvertible): boolean;

  isReadableFileAtPath(path: string): boolean;

  isWritableFileAtPath(path: string): boolean;

  isExecutableFileAtPath(path: string): boolean;

  isDeletableFileAtPath(path: string): boolean;

  contentsEqualAtPathAndPath(path1: string, path2: string): boolean;

  displayNameAtPath(path: string): string;

  componentsToDisplayForPath(path: string): NSArray;

  enumeratorAtPath(path: string): NSDirectoryEnumerator;

  subpathsAtPath(path: string): NSArray;

  contentsAtPath(path: string): NSData;

  createFileAtPathContentsAttributes(path: string, data: NSData | null, attr: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): boolean;

  fileSystemRepresentationWithPath(path: string): string;

  stringWithFileSystemRepresentationLength(str: string, len: number): string;
}

declare class NSDate extends NSObject implements NSCopying, NSSecureCoding {
  readonly timeIntervalSinceReferenceDate: number;

  init(): this;

  initWithTimeIntervalSinceReferenceDate(ti: number): this;

  initWithCoder(coder: NSCoder): this;

  timeIntervalSinceDate(anotherDate: NSDate): number;

  readonly timeIntervalSinceNow: number;

  readonly timeIntervalSince1970: number;

  earlierDate(anotherDate: NSDate): NSDate;

  laterDate(anotherDate: NSDate): NSDate;

  compare(other: NSDate): interop.Enum<typeof NSComparisonResult>;

  isEqualToDate(otherDate: NSDate): boolean;

  readonly description: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  static readonly timeIntervalSinceReferenceDate: number;

  static date<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dateWithTimeIntervalSinceNow<This extends abstract new (...args: any) => any>(this: This, secs: number): InstanceType<This>;

  static dateWithTimeIntervalSinceReferenceDate<This extends abstract new (...args: any) => any>(this: This, ti: number): InstanceType<This>;

  static dateWithTimeIntervalSince1970<This extends abstract new (...args: any) => any>(this: This, secs: number): InstanceType<This>;

  static dateWithTimeIntervalSinceDate<This extends abstract new (...args: any) => any>(this: This, secsToBeAdded: number, date: NSDate): InstanceType<This>;

  static readonly distantFuture: NSDate;

  static readonly distantPast: NSDate;

  initWithTimeIntervalSinceNow(secs: number): this;

  initWithTimeIntervalSince1970(secs: number): this;

  initWithTimeIntervalSinceDate(secsToBeAdded: number, date: NSDate): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSDateComponents extends NSObject implements NSCopying, NSSecureCoding {
  era: number;

  year: number;

  month: number;

  day: number;

  hour: number;

  minute: number;

  second: number;

  weekday: number;

  weekdayOrdinal: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURL extends NSObject implements NSSecureCoding, NSCopying {
  initFileURLWithPath(path: string): this;

  static fileURLWithPath(path: string): NSURL;

  initWithString(URLString: string): this;

  initWithStringRelativeToURL(URLString: string, baseURL: NSURL | null): this;

  static URLWithString<This extends abstract new (...args: any) => any>(this: This, URLString: string): InstanceType<This>;

  static URLWithStringRelativeToURL<This extends abstract new (...args: any) => any>(this: This, URLString: string, baseURL: NSURL | null): InstanceType<This>;

  readonly absoluteString: string;

  readonly relativeString: string;

  readonly baseURL: NSURL;

  readonly absoluteURL: NSURL;

  readonly scheme: string;

  readonly resourceSpecifier: string;

  readonly host: string;

  readonly port: NSNumber;

  readonly user: string;

  readonly password: string;

  readonly path: string;

  readonly fragment: string;

  readonly query: string;

  readonly relativePath: string;

  readonly isFileURL: boolean;

  readonly standardizedURL: NSURL;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSConstantString extends NSSimpleCString {
}

declare class NSAssertionHandler extends NSObject {
  static readonly currentHandler: NSAssertionHandler;

  handleFailureInMethodObjectFileLineNumberDescription(selector: string, object: interop.Object, fileName: string, line: number, format: string | null): void;

  handleFailureInFunctionFileLineNumberDescription(functionName: string, fileName: string, line: number, format: string | null): void;
}

declare class NSScanner extends NSObject implements NSCopying {
  readonly string: string;

  scanLocation: number;

  charactersToBeSkipped: NSCharacterSet;

  caseSensitive: boolean;

  locale: interop.Object;

  initWithString(string: string): this;

  scanInt(result: interop.PointerConvertible): boolean;

  scanLongLong(result: interop.PointerConvertible): boolean;

  scanFloat(result: interop.PointerConvertible): boolean;

  scanDouble(result: interop.PointerConvertible): boolean;

  scanHexInt(result: interop.PointerConvertible): boolean;

  scanStringIntoString(string: string, result: interop.PointerConvertible): boolean;

  scanCharactersFromSetIntoString(set: NSCharacterSet, result: interop.PointerConvertible): boolean;

  scanUpToStringIntoString(string: string, result: interop.PointerConvertible): boolean;

  scanUpToCharactersFromSetIntoString(set: NSCharacterSet, result: interop.PointerConvertible): boolean;

  readonly isAtEnd: boolean;

  static scannerWithString<This extends abstract new (...args: any) => any>(this: This, string: string): InstanceType<This>;

  static localizedScannerWithString(string: string): interop.Object;

  scanDecimal(dcm: interop.PointerConvertible): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSKeyValueSharedObservers extends NSObject {
  initWithObservableClass(observableClass: interop.Object): this;

  addSharedObserverForKeyOptionsContext(observer: interop.Object, key: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  snapshot(): NSKeyValueSharedObserversSnapshot;
}

declare class NSDateFormatter extends NSFormatter {
  getObjectValueForStringRangeError(obj: interop.PointerConvertible, string: string, rangep: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  stringFromDate(date: NSDate): string;

  dateFromString(string: string): NSDate;

  static defaultFormatterBehavior: interop.Enum<typeof NSDateFormatterBehavior>;

  dateFormat: string;

  dateStyle: interop.Enum<typeof NSDateFormatterStyle>;

  timeStyle: interop.Enum<typeof NSDateFormatterStyle>;

  locale: NSLocale;

  generatesCalendarDates: boolean;

  formatterBehavior: interop.Enum<typeof NSDateFormatterBehavior>;

  timeZone: NSTimeZone;

  calendar: NSCalendar;

  isLenient: boolean;

  twoDigitStartDate: NSDate;

  defaultDate: NSDate;

  get eraSymbols(): NSArray;
  set eraSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get monthSymbols(): NSArray;
  set monthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortMonthSymbols(): NSArray;
  set shortMonthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get weekdaySymbols(): NSArray;
  set weekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortWeekdaySymbols(): NSArray;
  set shortWeekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  AMSymbol: string;

  PMSymbol: string;
}

declare class NSFormatter extends NSObject implements NSCopying, NSCoding {
  stringForObjectValue(obj: interop.Object | null): string;

  attributedStringForObjectValueWithDefaultAttributes(obj: interop.Object, attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): interop.Object;

  editingStringForObjectValue(obj: interop.Object): string;

  getObjectValueForStringErrorDescription(obj: interop.PointerConvertible, string: string, error: interop.PointerConvertible): boolean;

  isPartialStringValidNewEditingStringErrorDescription(partialString: string, newString: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription(partialStringPtr: interop.PointerConvertible, proposedSelRangePtr: interop.PointerConvertible, origString: string, origSelRange: _NSRange, error: interop.PointerConvertible): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSValue extends NSObject implements NSCopying, NSSecureCoding {
  readonly objCType: string;

  initWithBytesObjCType(value: interop.PointerConvertible, type: string): this;

  initWithCoder(coder: NSCoder): this;

  static valueWithBytesObjCType(value: interop.PointerConvertible, type: string): NSValue;

  static valueWithObjCType(value: interop.PointerConvertible, type: string): NSValue;

  static valueWithNonretainedObject(anObject: interop.Object | null): NSValue;

  readonly nonretainedObjectValue: interop.Object;

  static valueWithPointer(pointer: interop.PointerConvertible): NSValue;

  readonly pointerValue: interop.Pointer;

  isEqualToValue(value: NSValue): boolean;

  static valueWithRange(range: _NSRange): NSValue;

  readonly rangeValue: _NSRange;

  static valueWithSCNVector3(v: SCNVector3): NSValue;

  static valueWithSCNVector4(v: SCNVector4): NSValue;

  static valueWithSCNMatrix4(v: SCNMatrix4): NSValue;

  readonly SCNVector3Value: SCNVector3;

  readonly SCNVector4Value: SCNVector4;

  readonly SCNMatrix4Value: SCNMatrix4;

  static valueWithGCPoint2<This extends abstract new (...args: any) => any>(this: This, point: GCPoint2): InstanceType<This>;

  readonly GCPoint2Value: GCPoint2;

  static valueWithCMVideoDimensions(dimensions: CMVideoDimensions): NSValue;

  readonly CMVideoDimensionsValue: CMVideoDimensions;

  static valueWithCMTime(time: CMTime): NSValue;

  readonly CMTimeValue: CMTime;

  static valueWithCMTimeRange(timeRange: CMTimeRange): NSValue;

  readonly CMTimeRangeValue: CMTimeRange;

  static valueWithCMTimeMapping(timeMapping: CMTimeMapping): NSValue;

  readonly CMTimeMappingValue: CMTimeMapping;

  static valueWithMKCoordinate(coordinate: CLLocationCoordinate2D): NSValue;

  static valueWithMKCoordinateSpan(span: MKCoordinateSpan): NSValue;

  readonly MKCoordinateValue: CLLocationCoordinate2D;

  readonly MKCoordinateSpanValue: MKCoordinateSpan;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSBundle extends NSObject {
  static readonly mainBundle: NSBundle;

  static bundleWithPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  initWithPath(path: string): this;

  static bundleForClass(aClass: interop.Object): NSBundle;

  static bundleWithIdentifier(identifier: string): NSBundle;

  static readonly allBundles: NSArray;

  static readonly allFrameworks: NSArray;

  load(): boolean;

  readonly isLoaded: boolean;

  unload(): boolean;

  readonly bundlePath: string;

  readonly resourcePath: string;

  readonly executablePath: string;

  pathForAuxiliaryExecutable(executableName: string): string;

  readonly privateFrameworksPath: string;

  readonly sharedFrameworksPath: string;

  readonly sharedSupportPath: string;

  readonly builtInPlugInsPath: string;

  static pathForResourceOfTypeInDirectory(name: string | null, ext: string | null, bundlePath: string): string;

  static pathsForResourcesOfTypeInDirectory(ext: string | null, bundlePath: string): NSArray;

  pathForResourceOfType(name: string | null, ext: string | null): string;

  pathForResourceOfTypeInDirectory(name: string | null, ext: string | null, subpath: string | null): string;

  pathForResourceOfTypeInDirectoryForLocalization(name: string | null, ext: string | null, subpath: string | null, localizationName: string | null): string;

  pathsForResourcesOfTypeInDirectory(ext: string | null, subpath: string | null): NSArray;

  pathsForResourcesOfTypeInDirectoryForLocalization(ext: string | null, subpath: string | null, localizationName: string | null): NSArray;

  localizedStringForKeyValueTable(key: string, value: string | null, tableName: string | null): string;

  readonly bundleIdentifier: string;

  readonly infoDictionary: NSDictionary;

  readonly localizedInfoDictionary: NSDictionary;

  objectForInfoDictionaryKey(key: string): interop.Object;

  classNamed(className: string): interop.Object;

  readonly principalClass: interop.Object;

  readonly preferredLocalizations: NSArray;

  readonly localizations: NSArray;

  readonly developmentLocalization: string;

  static preferredLocalizationsFromArray(localizationsArray: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  static preferredLocalizationsFromArrayForPreferences(localizationsArray: NSArray<interop.Object> | Array<interop.Object>, preferencesArray: NSArray<interop.Object> | Array<interop.Object> | null): NSArray;
}

declare class NSDecimalNumberHandler extends NSObject implements NSDecimalNumberBehaviors, NSCoding {
  static readonly defaultDecimalNumberHandler: NSDecimalNumberHandler;

  initWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: interop.Enum<typeof NSRoundingMode>, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): this;

  static decimalNumberHandlerWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero<This extends abstract new (...args: any) => any>(this: This, roundingMode: interop.Enum<typeof NSRoundingMode>, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): InstanceType<This>;

  roundingMode(): interop.Enum<typeof NSRoundingMode>;

  scale(): number;

  exceptionDuringOperationErrorLeftOperandRightOperand(operation: string, error: interop.Enum<typeof NSCalculationError>, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSCoder extends NSObject {
  encodeValueOfObjCTypeAt(type: string, addr: interop.PointerConvertible): void;

  encodeDataObject(data: NSData): void;

  decodeDataObject(): NSData;

  versionForClassName(className: string): number;

  encodeObject(object: interop.Object | null): void;

  encodeRootObject(rootObject: interop.Object): void;

  encodeBycopyObject(anObject: interop.Object | null): void;

  encodeByrefObject(anObject: interop.Object | null): void;

  encodeConditionalObject(object: interop.Object | null): void;

  encodeValuesOfObjCTypes(types: string): void;

  encodeArrayOfObjCTypeCountAt(type: string, count: number, array: interop.PointerConvertible): void;

  encodeBytesLength(byteaddr: interop.PointerConvertible, length: number): void;

  decodeObject(): interop.Object;

  decodeValuesOfObjCTypes(types: string): void;

  decodeArrayOfObjCTypeCountAt(itemType: string, count: number, array: interop.PointerConvertible): void;

  decodeBytesWithReturnedLength(lengthp: interop.PointerConvertible): interop.Pointer;

  setObjectZone(zone: interop.PointerConvertible): void;

  objectZone(): interop.Pointer;

  readonly systemVersion: number;

  readonly allowsKeyedCoding: boolean;

  encodeObjectForKey(object: interop.Object | null, key: string): void;

  encodeConditionalObjectForKey(object: interop.Object | null, key: string): void;

  encodeBoolForKey(value: boolean, key: string): void;

  encodeIntForKey(value: number, key: string): void;

  encodeInt32ForKey(value: number, key: string): void;

  encodeInt64ForKey(value: number, key: string): void;

  encodeFloatForKey(value: number, key: string): void;

  encodeDoubleForKey(value: number, key: string): void;

  encodeBytesLengthForKey(bytes: interop.PointerConvertible, length: number, key: string): void;

  containsValueForKey(key: string): boolean;

  decodeObjectForKey(key: string): interop.Object;

  decodeBoolForKey(key: string): boolean;

  decodeIntForKey(key: string): number;

  decodeInt32ForKey(key: string): number;

  decodeInt64ForKey(key: string): number;

  decodeFloatForKey(key: string): number;

  decodeDoubleForKey(key: string): number;

  decodeBytesForKeyReturnedLength(key: string, lengthp: interop.PointerConvertible): interop.Pointer;

  encodeCMTimeForKey(time: CMTime, key: string): void;

  decodeCMTimeForKey(key: string): CMTime;

  encodeCMTimeRangeForKey(timeRange: CMTimeRange, key: string): void;

  decodeCMTimeRangeForKey(key: string): CMTimeRange;

  encodeCMTimeMappingForKey(timeMapping: CMTimeMapping, key: string): void;

  decodeCMTimeMappingForKey(key: string): CMTimeMapping;
}

declare class NSRecursiveLock extends NSObject implements NSLocking {
  tryLock(): boolean;

  lockBeforeDate(limit: NSDate): boolean;

  lock(): void;

  unlock(): void;
}

declare class NSXMLParser extends NSObject {
  initWithContentsOfURL(url: NSURL): this;

  initWithData(data: NSData): this;

  delegate: NSXMLParserDelegate;

  shouldProcessNamespaces: boolean;

  shouldReportNamespacePrefixes: boolean;

  parse(): boolean;

  abortParsing(): void;

  readonly parserError: NSError;

  shouldResolveExternalEntities: boolean;

  readonly publicID: string;

  readonly systemID: string;

  readonly lineNumber: number;

  readonly columnNumber: number;
}

declare class NSThread extends NSObject {
  static readonly currentThread: NSThread;

  static detachNewThreadSelectorToTargetWithObject(selector: string, target: interop.Object, argument: interop.Object | null): void;

  static isMultiThreaded(): boolean;

  readonly threadDictionary: NSMutableDictionary;

  static sleepUntilDate(date: NSDate): void;

  static sleepForTimeInterval(ti: number): void;

  static exit(): void;

  static threadPriority(): number;

  static setThreadPriority(p: number): boolean;
}

declare class NSMutableDictionary<KeyType = interop.Object, ObjectType = interop.Object> extends NSDictionary {
  removeObjectForKey(aKey: KeyType): void;

  setObjectForKey(anObject: ObjectType, aKey: NSCopying): void;

  init(): this;

  initWithCapacity(numItems: number): this;

  initWithCoder(coder: NSCoder): this;

  addEntriesFromDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  removeAllObjects(): void;

  removeObjectsForKeys(keyArray: NSArray<interop.Object> | Array<interop.Object>): void;

  setDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  static dictionaryWithCapacity<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, numItems: number): InstanceType<This>;

  static dictionaryWithContentsOfFile<KeyType, ObjectType>(path: string): NSMutableDictionary;

  static dictionaryWithContentsOfURL<KeyType, ObjectType>(url: NSURL): NSMutableDictionary;

  initWithContentsOfFile(path: string): this;

  initWithContentsOfURL(url: NSURL): this;

  setValueForKey(value: ObjectType | null, key: string): void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSMutableCharacterSet extends NSCharacterSet implements NSCopying, NSMutableCopying, NSSecureCoding {
  addCharactersInRange(aRange: _NSRange): void;

  removeCharactersInRange(aRange: _NSRange): void;

  addCharactersInString(aString: string): void;

  removeCharactersInString(aString: string): void;

  formUnionWithCharacterSet(otherSet: NSCharacterSet): void;

  formIntersectionWithCharacterSet(otherSet: NSCharacterSet): void;

  invert(): void;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly controlCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly whitespaceCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly whitespaceAndNewlineCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly decimalDigitCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly letterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly lowercaseLetterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly uppercaseLetterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly nonBaseCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly alphanumericCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly decomposableCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly illegalCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly punctuationCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly capitalizedLetterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static readonly symbolCharacterSet: NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static characterSetWithRange(aRange: _NSRange): NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static characterSetWithCharactersInString(aString: string): NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static characterSetWithBitmapRepresentation(data: NSData): NSMutableCharacterSet;

  // @ts-ignore MemberDecl.tsIgnore
  static characterSetWithContentsOfFile(fName: string): NSMutableCharacterSet;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSEnumerator<ObjectType = interop.Object> extends NSObject implements NSFastEnumeration {
  nextObject(): ObjectType;

  readonly allObjects: NSArray;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  readonly [Symbol.iterator]: () => Iterator<ObjectType>;

}

declare class NSDictionary<KeyType = interop.Object, ObjectType = interop.Object> extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
  readonly count: number;

  objectForKey(aKey: KeyType): ObjectType;

  keyEnumerator(): NSEnumerator;

  init(): this;

  initWithObjectsForKeysCount(objects: interop.PointerConvertible, keys: interop.PointerConvertible, cnt: number): this;

  initWithCoder(coder: NSCoder): this;

  readonly allKeys: NSArray;

  allKeysForObject(anObject: ObjectType): NSArray;

  readonly allValues: NSArray;

  readonly description: string;

  readonly descriptionInStringsFileFormat: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  descriptionWithLocaleIndent(locale: interop.Object | null, level: number): string;

  isEqualToDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): boolean;

  objectEnumerator(): NSEnumerator;

  objectsForKeysNotFoundMarker(keys: NSArray<interop.Object> | Array<interop.Object>, marker: ObjectType): NSArray;

  keysSortedByValueUsingSelector(comparator: string): NSArray;

  static dictionary<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dictionaryWithObjectForKey<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, object: ObjectType, key: NSCopying): InstanceType<This>;

  static dictionaryWithObjectsForKeysCount<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: interop.PointerConvertible, keys: interop.PointerConvertible, cnt: number): InstanceType<This>;

  static dictionaryWithObjectsAndKeys<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, firstObject: interop.Object): InstanceType<This>;

  static dictionaryWithDictionary<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): InstanceType<This>;

  static dictionaryWithObjectsForKeys<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: NSArray<interop.Object> | Array<interop.Object>, keys: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithObjectsAndKeys(firstObject: interop.Object): this;

  initWithDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  initWithDictionaryCopyItems(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, flag: boolean): this;

  initWithObjectsForKeys(objects: NSArray<interop.Object> | Array<interop.Object>, keys: NSArray<interop.Object> | Array<interop.Object>): this;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  fileSize(): number;

  fileModificationDate(): NSDate;

  fileType(): string;

  filePosixPermissions(): number;

  fileOwnerAccountName(): string;

  fileGroupOwnerAccountName(): string;

  fileSystemNumber(): number;

  fileSystemFileNumber(): number;

  fileExtensionHidden(): boolean;

  fileHFSCreatorCode(): number;

  fileHFSTypeCode(): number;

  fileIsImmutable(): boolean;

  fileIsAppendOnly(): boolean;

  fileCreationDate(): NSDate;

  fileOwnerAccountID(): NSNumber;

  fileGroupOwnerAccountID(): NSNumber;

  valueForKey(key: string): ObjectType;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  readonly [Symbol.iterator]: () => Iterator<any>;

}

declare class NSLocale extends NSObject implements NSCopying, NSSecureCoding {
  objectForKey(key: string): interop.Object;

  displayNameForKeyValue(key: string, value: interop.Object): string;

  initWithLocaleIdentifier(string: string): this;

  initWithCoder(coder: NSCoder): this;

  readonly localeIdentifier: string;

  static readonly currentLocale: NSLocale;

  static readonly systemLocale: NSLocale;

  static readonly availableLocaleIdentifiers: NSArray;

  static readonly ISOLanguageCodes: NSArray;

  static readonly ISOCountryCodes: NSArray;

  static readonly ISOCurrencyCodes: NSArray;

  static componentsFromLocaleIdentifier(string: string): NSDictionary;

  static localeIdentifierFromComponents(dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): string;

  static canonicalLocaleIdentifierFromString(string: string): string;

  static canonicalLanguageIdentifierFromString(string: string): string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSMutableString extends NSString {
  replaceCharactersInRangeWithString(range: _NSRange, aString: string): void;

  insertStringAtIndex(aString: string, loc: number): void;

  deleteCharactersInRange(range: _NSRange): void;

  appendString(aString: string): void;

  appendFormat(format: string): void;

  setString(aString: string): void;

  replaceOccurrencesOfStringWithStringOptionsRange(target: string, replacement: string, options: interop.Enum<typeof NSStringCompareOptions>, searchRange: _NSRange): number;

  initWithCapacity(capacity: number): this;

  static stringWithCapacity(capacity: number): NSMutableString;
}

declare class NSMutableArray<ObjectType = interop.Object> extends NSArray {
  addObject(anObject: ObjectType): void;

  insertObjectAtIndex(anObject: ObjectType, index: number): void;

  removeLastObject(): void;

  removeObjectAtIndex(index: number): void;

  replaceObjectAtIndexWithObject(index: number, anObject: ObjectType): void;

  init(): this;

  initWithCapacity(numItems: number): this;

  initWithCoder(coder: NSCoder): this;

  addObjectsFromArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  exchangeObjectAtIndexWithObjectAtIndex(idx1: number, idx2: number): void;

  removeAllObjects(): void;

  removeObjectInRange(anObject: ObjectType, range: _NSRange): void;

  removeObject(anObject: ObjectType): void;

  removeObjectIdenticalToInRange(anObject: ObjectType, range: _NSRange): void;

  removeObjectIdenticalTo(anObject: ObjectType): void;

  removeObjectsInArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  removeObjectsInRange(range: _NSRange): void;

  replaceObjectsInRangeWithObjectsFromArrayRange(range: _NSRange, otherArray: NSArray<interop.Object> | Array<interop.Object>, otherRange: _NSRange): void;

  replaceObjectsInRangeWithObjectsFromArray(range: _NSRange, otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  setArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  sortUsingFunctionContext(compare: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => number | null, context: interop.PointerConvertible): void;

  sortUsingSelector(comparator: string): void;

  insertObjectsAtIndexes(objects: NSArray<interop.Object> | Array<interop.Object>, indexes: NSIndexSet): void;

  removeObjectsAtIndexes(indexes: NSIndexSet): void;

  replaceObjectsAtIndexesWithObjects(indexes: NSIndexSet, objects: NSArray<interop.Object> | Array<interop.Object>): void;

  static arrayWithCapacity<ObjectType, This extends abstract new (...args: any) => any>(this: This, numItems: number): InstanceType<This>;

  static arrayWithContentsOfFile<ObjectType>(path: string): NSMutableArray;

  static arrayWithContentsOfURL<ObjectType>(url: NSURL): NSMutableArray;

  initWithContentsOfFile(path: string): this;

  initWithContentsOfURL(url: NSURL): this;

  sortUsingDescriptors(sortDescriptors: NSArray<interop.Object> | Array<interop.Object>): void;

  filterUsingPredicate(predicate: interop.Object): void;
}

declare class NSMutableIndexSet extends NSIndexSet {
  addIndexes(indexSet: NSIndexSet): void;

  removeIndexes(indexSet: NSIndexSet): void;

  removeAllIndexes(): void;

  addIndex(value: number): void;

  removeIndex(value: number): void;

  addIndexesInRange(range: _NSRange): void;

  removeIndexesInRange(range: _NSRange): void;

  shiftIndexesStartingAtIndexBy(index: number, delta: number): void;
}

declare class NSCalendar extends NSObject implements NSCopying, NSSecureCoding {
  static readonly currentCalendar: NSCalendar;

  initWithCalendarIdentifier(ident: string): this;

  readonly calendarIdentifier: string;

  locale: NSLocale;

  timeZone: NSTimeZone;

  firstWeekday: number;

  minimumDaysInFirstWeek: number;

  minimumRangeOfUnit(unit: interop.Enum<typeof NSCalendarUnit>): _NSRange;

  maximumRangeOfUnit(unit: interop.Enum<typeof NSCalendarUnit>): _NSRange;

  rangeOfUnitInUnitForDate(smaller: interop.Enum<typeof NSCalendarUnit>, larger: interop.Enum<typeof NSCalendarUnit>, date: NSDate): _NSRange;

  ordinalityOfUnitInUnitForDate(smaller: interop.Enum<typeof NSCalendarUnit>, larger: interop.Enum<typeof NSCalendarUnit>, date: NSDate): number;

  dateFromComponents(comps: NSDateComponents): NSDate;

  componentsFromDate(unitFlags: interop.Enum<typeof NSCalendarUnit>, date: NSDate): NSDateComponents;

  dateByAddingComponentsToDateOptions(comps: NSDateComponents, date: NSDate, opts: interop.Enum<typeof NSCalendarOptions>): NSDate;

  componentsFromDateToDateOptions(unitFlags: interop.Enum<typeof NSCalendarUnit>, startingDate: NSDate, resultDate: NSDate, opts: interop.Enum<typeof NSCalendarOptions>): NSDateComponents;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSNotificationCenter extends NSObject {
  static readonly defaultCenter: NSNotificationCenter;

  addObserverSelectorNameObject(observer: interop.Object, aSelector: string, aName: string | null, anObject: interop.Object | null): void;

  postNotification(notification: NSNotification): void;

  postNotificationNameObject(aName: string, anObject: interop.Object | null): void;

  postNotificationNameObjectUserInfo(aName: string, anObject: interop.Object | null, aUserInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  removeObserver(observer: interop.Object): void;

  removeObserverNameObject(observer: interop.Object, aName: string | null, anObject: interop.Object | null): void;
}

