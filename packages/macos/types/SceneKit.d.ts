/// <reference types="@nativescript/objc-node-api" />
/// <reference path="./Runtime.d.ts" />
/// <reference path="./AppKit.d.ts" />
/// <reference path="./QuartzCore.d.ts" />

declare const SCNSceneSourceAssetAuthorKey: string;

declare const SCNLightTypeArea: string;

declare const SCNLightShadowFarClippingKey: string;

declare const SCNLightShadowNearClippingKey: string;

declare const SCNLightAttenuationFalloffExponentKey: string;

declare const SCNLightAttenuationStartKey: string;

declare const SCNPhysicsTestSearchModeAny: string;

declare const SCNPhysicsTestBackfaceCullingKey: string;

declare const SCNPhysicsShapeOptionCollisionMargin: string;

declare const SCNPhysicsShapeScaleKey: string;

declare const SCNPhysicsShapeKeepAsCompoundKey: string;

declare const SCNParticlePropertyCharge: string;

declare const SCNParticlePropertyLife: string;

declare const SCNParticlePropertyPosition: string;

declare const SCNGeometrySourceSemanticBoneIndices: string;

declare const SCNGeometrySourceSemanticBoneWeights: string;

declare const SCNLightingModelShadowOnly: string;

declare const SCNLightingModelConstant: string;

declare const SCNLightTypeProbe: string;

declare const SCNLightTypeSpot: string;

declare const SCNLightTypeAmbient: string;

declare const SCNModelViewProjectionTransform: string;

declare const SCNModelViewTransform: string;

declare const SCNViewTransform: string;

declare const SCNModelTransform: string;

declare const SCNSceneUpAxisAttributeKey: string;

declare const SCNSceneFrameRateAttributeKey: string;

declare const SCNSceneExportDestinationURL: string;

declare const SCNConsistencyMissingAttributeError: number;

declare const SCNConsistencyInvalidCountError: number;

declare const SCNConsistencyElementTypeErrorKey: string;

declare const SCNConsistencyElementIDErrorKey: string;

declare const SCNSceneSourceAnimationImportPolicyPlayUsingSceneTimeBase: string;

declare const SCNSceneSourceAnimationImportPolicyPlayRepeatedly: string;

declare const SCNSceneSourceAnimationImportPolicyKey: string;

declare const SCNSceneSourceConvertToYUpKey: string;

declare const SCNSceneSourceConvertUnitsToMetersKey: string;

declare const SCNSceneSourceStrictConformanceKey: string;

declare const SCNSceneSourceCreateNormalsIfAbsentKey: string;

declare const SCNSceneSourceAssetUnitMeterKey: string;

declare const SCNSceneSourceAssetUnitNameKey: string;

declare const SCNSceneSourceAssetUnitKey: string;

declare const SCNSceneSourceAssetContributorsKey: string;

declare const SCNShaderModifierEntryPointGeometry: string;

declare const SCNHitTestSortResultsKey: string;

declare const SCNHitTestFirstFoundOnlyKey: string;

declare const SCNHitTestOptionSearchMode: string;

declare const SCNHitTestOptionCategoryBitMask: string;

declare const SCNHitTestIgnoreHiddenNodesKey: string;

declare const SCNHitTestRootNodeKey: string;

declare const SCNHitTestIgnoreChildNodesKey: string;

declare const SCNHitTestClipToZRangeKey: string;

declare const SCNErrorDomain: string;

declare const SCNMatrix4Identity: CATransform3D;

declare const SCNSceneSourceAnimationImportPolicyDoNotPlay: string;

declare const SCNSceneEndTimeAttributeKey: string;

declare const SCNSceneSourceAssetUpAxisKey: string;

declare const SCNPreferredDeviceKey: string;

declare const SCNShaderModifierEntryPointLightingModel: string;

declare const SCNHitTestOptionIgnoreLightArea: string;

declare const SCNPhysicsTestSearchModeAll: string;

declare const SCNParticlePropertyContactPoint: string;

declare const SCNProgramMappingChannelKey: string;

declare const SCNPhysicsShapeTypeConvexHull: string;

declare const SCNPreferLowPowerDeviceKey: string;

declare const SCNSceneSourceLoadingOptionPreserveOriginalTopology: string;

declare const SCNLightTypeDirectional: string;

declare const SCNGeometrySourceSemanticTexcoord: string;

declare const SCNParticlePropertyAngle: string;

declare const SCNGeometrySourceSemanticVertex: string;

declare const SCNLightAttenuationEndKey: string;

declare const SCNSceneSourceAssetDirectoryURLsKey: string;

declare const SCNConsistencyMissingElementError: number;

declare const SCNLightingModelLambert: string;

declare const SCNGeometrySourceSemanticNormal: string;

declare const SCNParticlePropertyAngularVelocity: string;

declare const SCNProjectionTransform: string;

declare const SCNPhysicsTestCollisionBitMaskKey: string;

declare const SCNPreferredRenderingAPIKey: string;

declare const SCNPhysicsTestSearchModeClosest: string;

declare const SCNVector3Zero: SCNVector3;

declare const SCNGeometrySourceSemanticTangent: string;

declare const SCNNormalTransform: string;

declare const SCNHitTestBoundingBoxOnlyKey: string;

declare const SCNLightSpotInnerAngleKey: string;

declare const SCNParticlePropertyVelocity: string;

declare const SCNConsistencyInvalidArgumentError: number;

declare const SCNSceneSourceAssetAuthoringToolKey: string;

declare const SCNParticlePropertyContactNormal: string;

declare const SCNParticlePropertyOpacity: string;

declare const SCNProgramCompilationError: number;

declare const SCNConsistencyInvalidURIError: number;

declare const SCNShaderModifierEntryPointFragment: string;

declare const SCNSceneSourceOverrideAssetURLsKey: string;

declare const SCNShaderModifierEntryPointSurface: string;

declare const SCNSceneSourceAnimationImportPolicyPlay: string;

declare const SCNPhysicsShapeTypeBoundingBox: string;

declare const SCNVector4Zero: SCNVector4;

declare const SCNHitTestBackFaceCullingKey: string;

declare const SCNParticlePropertyRotationAxis: string;

declare const SCNPhysicsShapeTypeConcavePolyhedron: string;

declare const SCNLightingModelPhong: string;

declare const SCNParticlePropertyFriction: string;

declare const SCNSceneSourceUseSafeModeKey: string;

declare const SCNConsistencyLineNumberErrorKey: string;

declare const SCNSceneSourceCheckConsistencyKey: string;

declare const SCNParticlePropertyColor: string;

declare const SCNGeometrySourceSemanticEdgeCrease: string;

declare const SCNLightingModelBlinn: string;

declare const SCNParticlePropertyFrame: string;

declare const SCNParticlePropertySize: string;

declare const SCNDetailedErrorsKey: string;

declare const SCNGeometrySourceSemanticVertexCrease: string;

declare const SCNPhysicsShapeTypeKey: string;

declare const SCNLightSpotOuterAngleKey: string;

declare const SCNConsistencyXMLSchemaValidationError: number;

declare const SCNParticlePropertyFrameRate: string;

declare const SCNSceneSourceAssetCreatedDateKey: string;

declare const SCNLightTypeIES: string;

declare const SCNLightTypeOmni: string;

declare const SCNLightingModelPhysicallyBased: string;

declare const SCNParticlePropertyBounce: string;

declare const SCNGeometrySourceSemanticColor: string;

declare const SCNSceneSourceAssetModifiedDateKey: string;

declare const SCNPhysicsTestSearchModeKey: string;

declare const SCNSceneStartTimeAttributeKey: string;

declare const SCNSceneSourceFlattenSceneKey: string;

declare const SCNDebugOptions: {
  None: 0,
  ShowPhysicsShapes: 1,
  ShowBoundingBoxes: 2,
  ShowLightInfluences: 4,
  ShowLightExtents: 8,
  ShowPhysicsFields: 16,
  ShowWireframe: 32,
  RenderAsWireframe: 64,
  ShowSkeletons: 128,
  ShowCreases: 256,
  ShowConstraints: 512,
  ShowCameras: 1024,
};

declare const SCNBufferFrequency: {
  Frame: 0,
  Node: 1,
  Shadable: 2,
};

declare const SCNInteractionMode: {
  Fly: 0,
  OrbitTurntable: 1,
  OrbitAngleMapping: 2,
  OrbitCenteredArcball: 3,
  OrbitArcball: 4,
  Pan: 5,
  Truck: 6,
};

declare const SCNReferenceLoadingPolicy: {
  Immediate: 0,
  OnDemand: 1,
};

declare const SCNBillboardAxis: {
  X: 1,
  Y: 2,
  Z: 4,
  All: 7,
};

declare const SCNGeometryPrimitiveType: {
  Triangles: 0,
  TriangleStrip: 1,
  Line: 2,
  Point: 3,
  Polygon: 4,
};

declare const SCNTransparencyMode: {
  AOne: 0,
  RGBZero: 1,
  SingleLayer: 2,
  DualLayer: 3,
  Default: 0,
};

declare const SCNCullMode: {
  Back: 0,
  Front: 1,
};

declare const SCNFillMode: {
  Fill: 0,
  Lines: 1,
};

declare const SCNLightAreaType: {
  Rectangle: 1,
  Polygon: 4,
};

declare const SCNLightProbeUpdateType: {
  Never: 0,
  Realtime: 1,
};

declare const SCNMovabilityHint: {
  Fixed: 0,
  Movable: 1,
};

declare const SCNSceneSourceStatus: {
  Error: -1,
  Parsing: 4,
  Validating: 8,
  Processing: 12,
  Complete: 16,
};

declare const SCNRenderingAPI: {
  Metal: 0,
  OpenGLLegacy: 1,
  OpenGLCore32: 2,
  OpenGLCore41: 3,
};

declare const SCNAntialiasingMode: {
  None: 0,
  Multisampling2X: 1,
  Multisampling4X: 2,
  Multisampling8X: 3,
  Multisampling16X: 4,
};

declare const SCNColorMask: {
  None: 0,
  Red: 8,
  Green: 4,
  Blue: 2,
  Alpha: 1,
  All: 15,
};

declare const SCNParticleSortingMode: {
  None: 0,
  ProjectedDepth: 1,
  Distance: 2,
  OldestFirst: 3,
  YoungestFirst: 4,
};

declare const SCNCameraProjectionDirection: {
  Vertical: 0,
  Horizontal: 1,
};

declare const SCNNodeFocusBehavior: {
  None: 0,
  Occluding: 1,
  Focusable: 2,
};

declare const SCNParticleInputMode: {
  Life: 0,
  Distance: 1,
  OtherProperty: 2,
};

declare const SCNPhysicsFieldScope: {
  Inside: 0,
  Outside: 1,
};

declare const SCNLightProbeType: {
  Irradiance: 0,
  Radiance: 1,
};

declare const SCNPhysicsBodyType: {
  Static: 0,
  Dynamic: 1,
  Kinematic: 2,
};

declare const SCNParticleModifierStage: {
  PreDynamics: 0,
  PostDynamics: 1,
  PreCollision: 2,
  PostCollision: 3,
};

declare const SCNChamferMode: {
  Both: 0,
  Front: 1,
  Back: 2,
};

declare const SCNFilterMode: {
  None: 0,
  Nearest: 1,
  Linear: 2,
};

declare const SCNParticleOrientationMode: {
  BillboardScreenAligned: 0,
  BillboardViewAligned: 1,
  Free: 2,
  BillboardYAligned: 3,
};

declare const SCNActionTimingMode: {
  Linear: 0,
  EaseIn: 1,
  EaseOut: 2,
  EaseInEaseOut: 3,
};

declare const SCNParticleBirthDirection: {
  Constant: 0,
  SurfaceNormal: 1,
  Random: 2,
};

declare const SCNPhysicsCollisionCategory: {
  Default: 1,
  Static: 2,
  All: -1,
};

declare const SCNTessellationSmoothingMode: {
  None: 0,
  PNTriangles: 1,
  Phong: 2,
};

declare const SCNShadowMode: {
  Forward: 0,
  Deferred: 1,
  Modulated: 2,
};

declare const SCNWrapMode: {
  Clamp: 1,
  Repeat: 2,
  ClampToBorder: 3,
  Mirror: 4,
};

declare const SCNBlendMode: {
  Alpha: 0,
  Add: 1,
  Subtract: 2,
  Multiply: 3,
  Screen: 4,
  Replace: 5,
  Max: 6,
};

declare const SCNMorpherCalculationMode: {
  Normalized: 0,
  Additive: 1,
};

declare const SCNParticleEvent: {
  Birth: 0,
  Death: 1,
  Collision: 2,
};

declare const SCNParticleBlendMode: {
  Additive: 0,
  Subtract: 1,
  Multiply: 2,
  Screen: 3,
  Alpha: 4,
  Replace: 5,
};

declare const SCNParticleBirthLocation: {
  Surface: 0,
  Volume: 1,
  Vertex: 2,
};

declare const SCNHitTestSearchMode: {
  Closest: 0,
  All: 1,
  Any: 2,
};

declare const SCNParticleImageSequenceAnimationMode: {
  Repeat: 0,
  Clamp: 1,
  AutoReverse: 2,
};

declare class SCNVector3 {
  constructor(init?: SCNVector3);
  x: number;
  y: number;
  z: number;
}

declare class SCNVector4 {
  constructor(init?: SCNVector4);
  x: number;
  y: number;
  z: number;
  w: number;
}

declare function SCNVector3EqualToVector3(a: SCNVector3, b: SCNVector3): boolean;

declare function SCNVector4EqualToVector4(a: SCNVector4, b: SCNVector4): boolean;

declare function SCNMatrix4IsIdentity(m: CATransform3D): boolean;

declare function SCNMatrix4EqualToMatrix4(a: CATransform3D, b: CATransform3D): boolean;

declare function SCNMatrix4MakeRotation(angle: number, x: number, y: number, z: number): CATransform3D;

declare function SCNMatrix4Scale(m: CATransform3D, sx: number, sy: number, sz: number): CATransform3D;

declare function SCNMatrix4Rotate(m: CATransform3D, angle: number, x: number, y: number, z: number): CATransform3D;

declare function SCNMatrix4Invert(m: CATransform3D): CATransform3D;

declare function SCNMatrix4Mult(a: CATransform3D, b: CATransform3D): CATransform3D;

declare function SCNMatrix4ToGLKMatrix4(mat: CATransform3D): _GLKMatrix4;

declare function SCNMatrix4FromGLKMatrix4(mat: _GLKMatrix4): CATransform3D;

declare function SCNExportJavaScriptModule(context: JSContext): void;

declare interface SCNAvoidOccluderConstraintDelegate extends NSObjectProtocol {
  avoidOccluderConstraintShouldAvoidOccluderForNode?(constraint: SCNAvoidOccluderConstraint, occluder: SCNNode, node: SCNNode): boolean;

  avoidOccluderConstraintDidAvoidOccluderForNode?(constraint: SCNAvoidOccluderConstraint, occluder: SCNNode, node: SCNNode): void;
}

declare class SCNAvoidOccluderConstraintDelegate extends NativeObject implements SCNAvoidOccluderConstraintDelegate {
}

declare interface SCNCameraControllerDelegate extends NSObjectProtocol {
  cameraInertiaWillStartForController?(cameraController: SCNCameraController): void;

  cameraInertiaDidEndForController?(cameraController: SCNCameraController): void;
}

declare class SCNCameraControllerDelegate extends NativeObject implements SCNCameraControllerDelegate {
}

declare interface SCNCameraControlConfiguration extends NSObjectProtocol {
  autoSwitchToFreeCamera: boolean;

  allowsTranslation: boolean;

  flyModeVelocity: number;

  panSensitivity: number;

  truckSensitivity: number;

  rotationSensitivity: number;

  setAutoSwitchToFreeCamera(autoSwitchToFreeCamera: boolean): void;

  setAllowsTranslation(allowsTranslation: boolean): void;

  setFlyModeVelocity(flyModeVelocity: number): void;

  setPanSensitivity(panSensitivity: number): void;

  setTruckSensitivity(truckSensitivity: number): void;

  setRotationSensitivity(rotationSensitivity: number): void;
}

declare class SCNCameraControlConfiguration extends NativeObject implements SCNCameraControlConfiguration {
}

declare interface SCNProgramDelegate extends NSObjectProtocol {
  programBindValueForSymbolAtLocationProgramIDRenderer?(program: SCNProgram, symbol: string, location: number, programID: number, renderer: SCNRenderer): boolean;

  programUnbindValueForSymbolAtLocationProgramIDRenderer?(program: SCNProgram, symbol: string, location: number, programID: number, renderer: SCNRenderer): void;

  programHandleError?(program: SCNProgram, error: NSError): void;

  programIsOpaque?(program: SCNProgram): boolean;
}

declare class SCNProgramDelegate extends NativeObject implements SCNProgramDelegate {
}

declare interface SCNTechniqueSupport extends NSObjectProtocol {
  technique: SCNTechnique;

  setTechnique(technique: SCNTechnique): void;
}

declare class SCNTechniqueSupport extends NativeObject implements SCNTechniqueSupport {
}

declare interface SCNShadable extends NSObjectProtocol {
  program?: SCNProgram;

  handleBindingOfSymbolUsingBlock?(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  handleUnbindingOfSymbolUsingBlock?(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  get shaderModifiers(): NSDictionary | undefined;
  set shaderModifiers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | undefined);

  minimumLanguageVersion?: NSNumber;

  setProgram?(program: SCNProgram): void;

  setShaderModifiers?(shaderModifiers: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  setMinimumLanguageVersion?(minimumLanguageVersion: NSNumber | null): void;
}

declare class SCNShadable extends NativeObject implements SCNShadable {
}

declare interface SCNBufferStream extends NSObjectProtocol {
  writeBytesLength(bytes: interop.PointerConvertible, length: number): void;
}

declare class SCNBufferStream extends NativeObject implements SCNBufferStream {
}

declare interface SCNSceneRenderer extends NSObjectProtocol {
  scene: SCNScene;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  playing: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  jitteringEnabled: boolean;

  temporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;

  setScene(scene: SCNScene | null): void;

  setSceneTime(sceneTime: number): void;

  setDelegate(delegate: SCNSceneRendererDelegate | null): void;

  isPlaying(): boolean;

  setPlaying(playing: boolean): void;

  setLoops(loops: boolean): void;

  setPointOfView(pointOfView: SCNNode | null): void;

  setAutoenablesDefaultLighting(autoenablesDefaultLighting: boolean): void;

  isJitteringEnabled(): boolean;

  setJitteringEnabled(jitteringEnabled: boolean): void;

  isTemporalAntialiasingEnabled(): boolean;

  setTemporalAntialiasingEnabled(temporalAntialiasingEnabled: boolean): void;

  setShowsStatistics(showsStatistics: boolean): void;

  setDebugOptions(debugOptions: interop.Enum<typeof SCNDebugOptions>): void;

  setOverlaySKScene(overlaySKScene: SKScene): void;

  setAudioListener(audioListener: SCNNode | null): void;

  setCurrentTime(currentTime: number): void;

  setUsesReverseZ(usesReverseZ: boolean): void;
}

declare class SCNSceneRenderer extends NativeObject implements SCNSceneRenderer {
}

declare interface SCNAnimationProtocol extends NSObjectProtocol {
}

declare class SCNAnimationProtocol extends NativeObject implements SCNAnimationProtocol {
}

declare interface SCNPhysicsContactDelegate extends NSObjectProtocol {
  physicsWorldDidBeginContact?(world: SCNPhysicsWorld, contact: SCNPhysicsContact): void;

  physicsWorldDidUpdateContact?(world: SCNPhysicsWorld, contact: SCNPhysicsContact): void;

  physicsWorldDidEndContact?(world: SCNPhysicsWorld, contact: SCNPhysicsContact): void;
}

declare class SCNPhysicsContactDelegate extends NativeObject implements SCNPhysicsContactDelegate {
}

declare interface SCNSceneExportDelegate extends NSObjectProtocol {
  writeImageWithSceneDocumentURLOriginalImageURL?(image: NSImage, documentURL: NSURL, originalImageURL: NSURL | null): NSURL;
}

declare class SCNSceneExportDelegate extends NativeObject implements SCNSceneExportDelegate {
}

declare interface SCNBoundingVolume extends NSObjectProtocol {
  getBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): boolean;

  setBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): void;

  getBoundingSphereCenterRadius(center: interop.PointerConvertible, radius: interop.PointerConvertible): boolean;
}

declare class SCNBoundingVolume extends NativeObject implements SCNBoundingVolume {
}

declare interface SCNActionable extends NSObjectProtocol {
  runAction(action: SCNAction): void;

  runActionCompletionHandler(action: SCNAction, block: () => void | null): void;

  runActionForKey(action: SCNAction, key: string | null): void;

  runActionForKeyCompletionHandler(action: SCNAction, key: string | null, block: () => void | null): void;

  readonly hasActions: boolean;

  actionForKey(key: string): SCNAction;

  removeActionForKey(key: string): void;

  removeAllActions(): void;

  readonly actionKeys: NSArray;
}

declare class SCNActionable extends NativeObject implements SCNActionable {
}

declare interface SCNSceneRendererDelegate extends NSObjectProtocol {
  rendererUpdateAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererDidApplyAnimationsAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererDidSimulatePhysicsAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererDidApplyConstraintsAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererWillRenderSceneAtTime?(renderer: SCNSceneRenderer, scene: SCNScene, time: number): void;

  rendererDidRenderSceneAtTime?(renderer: SCNSceneRenderer, scene: SCNScene, time: number): void;
}

declare class SCNSceneRendererDelegate extends NativeObject implements SCNSceneRendererDelegate {
}

declare interface SCNNodeRendererDelegate extends NSObjectProtocol {
  renderNodeRendererArguments?(node: SCNNode, renderer: SCNRenderer, arguments$: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;
}

declare class SCNNodeRendererDelegate extends NativeObject implements SCNNodeRendererDelegate {
}

declare interface SCNAnimatable extends NSObjectProtocol {
  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;
}

declare class SCNAnimatable extends NativeObject implements SCNAnimatable {
}

declare class SCNTransaction extends NSObject {
  static begin(): void;

  static commit(): void;

  static flush(): void;

  static lock(): void;

  static unlock(): void;

  static animationDuration: number;

  static animationTimingFunction: CAMediaTimingFunction;

  static disableActions: boolean;

  static completionBlock: () => void;

  static valueForKey(key: string): interop.Object;

  static setValueForKey(value: interop.Object | null, key: string): void;

  static setAnimationDuration(animationDuration: number): void;

  static setAnimationTimingFunction(animationTimingFunction: CAMediaTimingFunction): void;

  static setDisableActions(disableActions: boolean): void;

  static setCompletionBlock(completionBlock: () => void | null): void;
}

declare class SCNShape extends SCNGeometry {
  static shapeWithPathExtrusionDepth<This extends abstract new (...args: any) => any>(this: This, path: NSBezierPath | null, extrusionDepth: number): InstanceType<This>;

  path: NSBezierPath;

  extrusionDepth: number;

  chamferMode: interop.Enum<typeof SCNChamferMode>;

  chamferRadius: number;

  chamferProfile: NSBezierPath;

  setPath(path: NSBezierPath | null): void;

  setExtrusionDepth(extrusionDepth: number): void;

  setChamferMode(chamferMode: interop.Enum<typeof SCNChamferMode>): void;

  setChamferRadius(chamferRadius: number): void;

  setChamferProfile(chamferProfile: NSBezierPath | null): void;
}

declare class SCNPhysicsWorld extends NSObject implements NSSecureCoding {
  gravity: SCNVector3;

  speed: number;

  timeStep: number;

  contactDelegate: SCNPhysicsContactDelegate;

  addBehavior(behavior: SCNPhysicsBehavior): void;

  removeBehavior(behavior: SCNPhysicsBehavior): void;

  removeAllBehaviors(): void;

  readonly allBehaviors: NSArray;

  rayTestWithSegmentFromPointToPointOptions(origin: SCNVector3, dest: SCNVector3, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  contactTestBetweenBodyAndBodyOptions(bodyA: SCNPhysicsBody, bodyB: SCNPhysicsBody, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  contactTestWithBodyOptions(body: SCNPhysicsBody, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  convexSweepTestWithShapeFromTransformToTransformOptions(shape: SCNPhysicsShape, from: CATransform3D, to: CATransform3D, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  updateCollisionPairs(): void;

  setGravity(gravity: SCNVector3): void;

  setSpeed(speed: number): void;

  setTimeStep(timeStep: number): void;

  setContactDelegate(contactDelegate: SCNPhysicsContactDelegate | null): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNParticleSystem extends NSObject implements NSCopying, NSSecureCoding, SCNAnimatable {
  static particleSystem<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static particleSystemNamedInDirectory<This extends abstract new (...args: any) => any>(this: This, name: string, directory: string | null): InstanceType<This>;

  emissionDuration: number;

  emissionDurationVariation: number;

  idleDuration: number;

  idleDurationVariation: number;

  loops: boolean;

  birthRate: number;

  birthRateVariation: number;

  warmupDuration: number;

  emitterShape: SCNGeometry;

  birthLocation: interop.Enum<typeof SCNParticleBirthLocation>;

  birthDirection: interop.Enum<typeof SCNParticleBirthDirection>;

  spreadingAngle: number;

  emittingDirection: SCNVector3;

  orientationDirection: SCNVector3;

  acceleration: SCNVector3;

  local: boolean;

  particleAngle: number;

  particleAngleVariation: number;

  particleVelocity: number;

  particleVelocityVariation: number;

  particleAngularVelocity: number;

  particleAngularVelocityVariation: number;

  particleLifeSpan: number;

  particleLifeSpanVariation: number;

  systemSpawnedOnDying: SCNParticleSystem;

  systemSpawnedOnCollision: SCNParticleSystem;

  systemSpawnedOnLiving: SCNParticleSystem;

  particleImage: interop.Object;

  imageSequenceColumnCount: number;

  imageSequenceRowCount: number;

  imageSequenceInitialFrame: number;

  imageSequenceInitialFrameVariation: number;

  imageSequenceFrameRate: number;

  imageSequenceFrameRateVariation: number;

  imageSequenceAnimationMode: interop.Enum<typeof SCNParticleImageSequenceAnimationMode>;

  particleColor: NSColor;

  particleColorVariation: SCNVector4;

  particleSize: number;

  particleSizeVariation: number;

  particleIntensity: number;

  particleIntensityVariation: number;

  blendMode: interop.Enum<typeof SCNParticleBlendMode>;

  blackPassEnabled: boolean;

  orientationMode: interop.Enum<typeof SCNParticleOrientationMode>;

  sortingMode: interop.Enum<typeof SCNParticleSortingMode>;

  lightingEnabled: boolean;

  affectedByGravity: boolean;

  affectedByPhysicsFields: boolean;

  particleDiesOnCollision: boolean;

  get colliderNodes(): NSArray;
  set colliderNodes(value: NSArray<interop.Object> | Array<interop.Object>);

  particleMass: number;

  particleMassVariation: number;

  particleBounce: number;

  particleBounceVariation: number;

  particleFriction: number;

  particleFrictionVariation: number;

  particleCharge: number;

  particleChargeVariation: number;

  dampingFactor: number;

  speedFactor: number;

  stretchFactor: number;

  fresnelExponent: number;

  writesToDepthBuffer: boolean;

  get propertyControllers(): NSDictionary;
  set propertyControllers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  reset(): void;

  handleEventForPropertiesWithBlock(event: interop.Enum<typeof SCNParticleEvent>, properties: NSArray<interop.Object> | Array<interop.Object>, block: (p1: interop.PointerConvertible, p2: interop.PointerConvertible, p3: interop.PointerConvertible, p4: number) => void): void;

  addModifierForPropertiesAtStageWithBlock(properties: NSArray<interop.Object> | Array<interop.Object>, stage: interop.Enum<typeof SCNParticleModifierStage>, block: (p1: interop.PointerConvertible, p2: interop.PointerConvertible, p3: number, p4: number, p5: number) => void): void;

  removeModifiersOfStage(stage: interop.Enum<typeof SCNParticleModifierStage>): void;

  removeAllModifiers(): void;

  setEmissionDuration(emissionDuration: number): void;

  setEmissionDurationVariation(emissionDurationVariation: number): void;

  setIdleDuration(idleDuration: number): void;

  setIdleDurationVariation(idleDurationVariation: number): void;

  setLoops(loops: boolean): void;

  setBirthRate(birthRate: number): void;

  setBirthRateVariation(birthRateVariation: number): void;

  setWarmupDuration(warmupDuration: number): void;

  setEmitterShape(emitterShape: SCNGeometry | null): void;

  setBirthLocation(birthLocation: interop.Enum<typeof SCNParticleBirthLocation>): void;

  setBirthDirection(birthDirection: interop.Enum<typeof SCNParticleBirthDirection>): void;

  setSpreadingAngle(spreadingAngle: number): void;

  setEmittingDirection(emittingDirection: SCNVector3): void;

  setOrientationDirection(orientationDirection: SCNVector3): void;

  setAcceleration(acceleration: SCNVector3): void;

  isLocal(): boolean;

  setLocal(local: boolean): void;

  setParticleAngle(particleAngle: number): void;

  setParticleAngleVariation(particleAngleVariation: number): void;

  setParticleVelocity(particleVelocity: number): void;

  setParticleVelocityVariation(particleVelocityVariation: number): void;

  setParticleAngularVelocity(particleAngularVelocity: number): void;

  setParticleAngularVelocityVariation(particleAngularVelocityVariation: number): void;

  setParticleLifeSpan(particleLifeSpan: number): void;

  setParticleLifeSpanVariation(particleLifeSpanVariation: number): void;

  setSystemSpawnedOnDying(systemSpawnedOnDying: SCNParticleSystem | null): void;

  setSystemSpawnedOnCollision(systemSpawnedOnCollision: SCNParticleSystem | null): void;

  setSystemSpawnedOnLiving(systemSpawnedOnLiving: SCNParticleSystem | null): void;

  setParticleImage(particleImage: interop.Object | null): void;

  setImageSequenceColumnCount(imageSequenceColumnCount: number): void;

  setImageSequenceRowCount(imageSequenceRowCount: number): void;

  setImageSequenceInitialFrame(imageSequenceInitialFrame: number): void;

  setImageSequenceInitialFrameVariation(imageSequenceInitialFrameVariation: number): void;

  setImageSequenceFrameRate(imageSequenceFrameRate: number): void;

  setImageSequenceFrameRateVariation(imageSequenceFrameRateVariation: number): void;

  setImageSequenceAnimationMode(imageSequenceAnimationMode: interop.Enum<typeof SCNParticleImageSequenceAnimationMode>): void;

  setParticleColor(particleColor: NSColor): void;

  setParticleColorVariation(particleColorVariation: SCNVector4): void;

  setParticleSize(particleSize: number): void;

  setParticleSizeVariation(particleSizeVariation: number): void;

  setParticleIntensity(particleIntensity: number): void;

  setParticleIntensityVariation(particleIntensityVariation: number): void;

  setBlendMode(blendMode: interop.Enum<typeof SCNParticleBlendMode>): void;

  isBlackPassEnabled(): boolean;

  setBlackPassEnabled(blackPassEnabled: boolean): void;

  setOrientationMode(orientationMode: interop.Enum<typeof SCNParticleOrientationMode>): void;

  setSortingMode(sortingMode: interop.Enum<typeof SCNParticleSortingMode>): void;

  isLightingEnabled(): boolean;

  setLightingEnabled(lightingEnabled: boolean): void;

  setAffectedByGravity(affectedByGravity: boolean): void;

  setAffectedByPhysicsFields(affectedByPhysicsFields: boolean): void;

  setParticleDiesOnCollision(particleDiesOnCollision: boolean): void;

  setColliderNodes(colliderNodes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  setParticleMass(particleMass: number): void;

  setParticleMassVariation(particleMassVariation: number): void;

  setParticleBounce(particleBounce: number): void;

  setParticleBounceVariation(particleBounceVariation: number): void;

  setParticleFriction(particleFriction: number): void;

  setParticleFrictionVariation(particleFrictionVariation: number): void;

  setParticleCharge(particleCharge: number): void;

  setParticleChargeVariation(particleChargeVariation: number): void;

  setDampingFactor(dampingFactor: number): void;

  setSpeedFactor(speedFactor: number): void;

  setStretchFactor(stretchFactor: number): void;

  setFresnelExponent(fresnelExponent: number): void;

  setWritesToDepthBuffer(writesToDepthBuffer: boolean): void;

  setPropertyControllers(propertyControllers: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

// @ts-ignore ClassDecl.tsIgnore
declare class SCNReferenceNode extends SCNNode {
  initWithURL(referenceURL: NSURL): this;

  // @ts-ignore MemberDecl.tsIgnore
  initWithCoder(aDecoder: NSCoder): this;

  static referenceNodeWithURL<This extends abstract new (...args: any) => any>(this: This, referenceURL: NSURL): InstanceType<This>;

  referenceURL: NSURL;

  loadingPolicy: interop.Enum<typeof SCNReferenceLoadingPolicy>;

  load(): void;

  unload(): void;

  readonly loaded: boolean;

  setReferenceURL(referenceURL: NSURL): void;

  setLoadingPolicy(loadingPolicy: interop.Enum<typeof SCNReferenceLoadingPolicy>): void;

  isLoaded(): boolean;
}

declare class SCNTechnique extends NSObject implements SCNAnimatable, NSCopying, NSSecureCoding {
  static techniqueWithDictionary(dictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): SCNTechnique;

  static techniqueBySequencingTechniques(techniques: NSArray<interop.Object> | Array<interop.Object>): SCNTechnique;

  handleBindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  readonly dictionaryRepresentation: NSDictionary;

  objectForKeyedSubscript(key: interop.Object): interop.Object;

  setObjectForKeyedSubscript(obj: interop.Object | null, key: NSCopying): void;

  library: MTLLibrary;

  setLibrary(library: MTLLibrary): void;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNSliderConstraint extends SCNConstraint {
  static sliderConstraint<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  collisionCategoryBitMask: number;

  radius: number;

  offset: SCNVector3;

  setCollisionCategoryBitMask(collisionCategoryBitMask: number): void;

  setRadius(radius: number): void;

  setOffset(offset: SCNVector3): void;
}

declare class SCNTransformConstraint extends SCNConstraint {
  static transformConstraintInWorldSpaceWithBlock<This extends abstract new (...args: any) => any>(this: This, world: boolean, block: (p1: SCNNode, p2: CATransform3D) => CATransform3D): InstanceType<This>;

  static positionConstraintInWorldSpaceWithBlock<This extends abstract new (...args: any) => any>(this: This, world: boolean, block: (p1: SCNNode, p2: SCNVector3) => SCNVector3): InstanceType<This>;

  static orientationConstraintInWorldSpaceWithBlock<This extends abstract new (...args: any) => any>(this: This, world: boolean, block: (p1: SCNNode, p2: SCNVector4) => SCNVector4): InstanceType<This>;
}

declare class SCNCameraController extends NSObject {
  delegate: SCNCameraControllerDelegate;

  pointOfView: SCNNode;

  interactionMode: interop.Enum<typeof SCNInteractionMode>;

  target: SCNVector3;

  automaticTarget: boolean;

  worldUp: SCNVector3;

  inertiaEnabled: boolean;

  inertiaFriction: number;

  readonly inertiaRunning: boolean;

  minimumVerticalAngle: number;

  maximumVerticalAngle: number;

  minimumHorizontalAngle: number;

  maximumHorizontalAngle: number;

  translateInCameraSpaceByXYZ(deltaX: number, deltaY: number, deltaZ: number): void;

  frameNodes(nodes: NSArray<interop.Object> | Array<interop.Object>): void;

  rotateByXY(deltaX: number, deltaY: number): void;

  rollByAroundScreenPointViewport(delta: number, point: CGPoint, viewport: CGSize): void;

  dollyByOnScreenPointViewport(delta: number, point: CGPoint, viewport: CGSize): void;

  rollAroundTarget(delta: number): void;

  dollyToTarget(delta: number): void;

  clearRoll(): void;

  stopInertia(): void;

  beginInteractionWithViewport(location: CGPoint, viewport: CGSize): void;

  continueInteractionWithViewportSensitivity(location: CGPoint, viewport: CGSize, sensitivity: number): void;

  endInteractionWithViewportVelocity(location: CGPoint, viewport: CGSize, velocity: CGPoint): void;

  setDelegate(delegate: SCNCameraControllerDelegate | null): void;

  setPointOfView(pointOfView: SCNNode | null): void;

  setInteractionMode(interactionMode: interop.Enum<typeof SCNInteractionMode>): void;

  setTarget(target: SCNVector3): void;

  setAutomaticTarget(automaticTarget: boolean): void;

  setWorldUp(worldUp: SCNVector3): void;

  setInertiaEnabled(inertiaEnabled: boolean): void;

  setInertiaFriction(inertiaFriction: number): void;

  isInertiaRunning(): boolean;

  setMinimumVerticalAngle(minimumVerticalAngle: number): void;

  setMaximumVerticalAngle(maximumVerticalAngle: number): void;

  setMinimumHorizontalAngle(minimumHorizontalAngle: number): void;

  setMaximumHorizontalAngle(maximumHorizontalAngle: number): void;
}

declare class SCNMaterialProperty extends NSObject implements SCNAnimatable, NSSecureCoding {
  static materialPropertyWithContents<This extends abstract new (...args: any) => any>(this: This, contents: interop.Object): InstanceType<This>;

  contents: interop.Object;

  intensity: number;

  minificationFilter: interop.Enum<typeof SCNFilterMode>;

  magnificationFilter: interop.Enum<typeof SCNFilterMode>;

  mipFilter: interop.Enum<typeof SCNFilterMode>;

  contentsTransform: CATransform3D;

  wrapS: interop.Enum<typeof SCNWrapMode>;

  wrapT: interop.Enum<typeof SCNWrapMode>;

  mappingChannel: number;

  textureComponents: interop.Enum<typeof SCNColorMask>;

  maxAnisotropy: number;

  static precomputedLightingEnvironmentContentsWithURLError(url: NSURL, error: interop.PointerConvertible): interop.Object;

  static precomputedLightingEnvironmentContentsWithDataError(data: NSData, error: interop.PointerConvertible): interop.Object;

  static precomputedLightingEnvironmentDataForContentsDeviceError(contents: interop.Object, device: MTLDevice | null, error: interop.PointerConvertible): NSData;

  setContents(contents: interop.Object | null): void;

  setIntensity(intensity: number): void;

  setMinificationFilter(minificationFilter: interop.Enum<typeof SCNFilterMode>): void;

  setMagnificationFilter(magnificationFilter: interop.Enum<typeof SCNFilterMode>): void;

  setMipFilter(mipFilter: interop.Enum<typeof SCNFilterMode>): void;

  setContentsTransform(contentsTransform: CATransform3D): void;

  setWrapS(wrapS: interop.Enum<typeof SCNWrapMode>): void;

  setWrapT(wrapT: interop.Enum<typeof SCNWrapMode>): void;

  setMappingChannel(mappingChannel: number): void;

  setTextureComponents(textureComponents: interop.Enum<typeof SCNColorMask>): void;

  setMaxAnisotropy(maxAnisotropy: number): void;

  borderColor: interop.Object;

  setBorderColor(borderColor: interop.Object | null): void;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNLevelOfDetail extends NSObject implements NSCopying, NSSecureCoding {
  static levelOfDetailWithGeometryScreenSpaceRadius<This extends abstract new (...args: any) => any>(this: This, geometry: SCNGeometry | null, radius: number): InstanceType<This>;

  static levelOfDetailWithGeometryWorldSpaceDistance<This extends abstract new (...args: any) => any>(this: This, geometry: SCNGeometry | null, distance: number): InstanceType<This>;

  readonly geometry: SCNGeometry;

  readonly screenSpaceRadius: number;

  readonly worldSpaceDistance: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNScene extends NSObject implements NSSecureCoding {
  static scene<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  readonly rootNode: SCNNode;

  readonly physicsWorld: SCNPhysicsWorld;

  attributeForKey(key: string): interop.Object;

  setAttributeForKey(attribute: interop.Object | null, key: string): void;

  readonly background: SCNMaterialProperty;

  readonly lightingEnvironment: SCNMaterialProperty;

  static sceneNamed<This extends abstract new (...args: any) => any>(this: This, name: string): InstanceType<This>;

  static sceneNamedInDirectoryOptions<This extends abstract new (...args: any) => any>(this: This, name: string, directory: string | null, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static sceneWithURLOptionsError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): InstanceType<This>;

  writeToURLOptionsDelegateProgressHandler(url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, delegate: SCNSceneExportDelegate | null, progressHandler: (p1: number, p2: NSError, p3: interop.PointerConvertible) => void | null): boolean;

  fogStartDistance: number;

  fogEndDistance: number;

  fogDensityExponent: number;

  fogColor: interop.Object;

  wantsScreenSpaceReflection: boolean;

  screenSpaceReflectionSampleCount: number;

  screenSpaceReflectionMaximumDistance: number;

  screenSpaceReflectionStride: number;

  paused: boolean;

  setFogStartDistance(fogStartDistance: number): void;

  setFogEndDistance(fogEndDistance: number): void;

  setFogDensityExponent(fogDensityExponent: number): void;

  setFogColor(fogColor: interop.Object): void;

  setWantsScreenSpaceReflection(wantsScreenSpaceReflection: boolean): void;

  setScreenSpaceReflectionSampleCount(screenSpaceReflectionSampleCount: number): void;

  setScreenSpaceReflectionMaximumDistance(screenSpaceReflectionMaximumDistance: number): void;

  setScreenSpaceReflectionStride(screenSpaceReflectionStride: number): void;

  isPaused(): boolean;

  setPaused(paused: boolean): void;

  addParticleSystemWithTransform(system: SCNParticleSystem, transform: CATransform3D): void;

  removeAllParticleSystems(): void;

  removeParticleSystem(system: SCNParticleSystem): void;

  readonly particleSystems: NSArray;

  static sceneWithMDLAsset<This extends abstract new (...args: any) => any>(this: This, mdlAsset: MDLAsset): InstanceType<This>;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNPhysicsField extends NSObject implements NSCopying, NSSecureCoding {
  strength: number;

  falloffExponent: number;

  minimumDistance: number;

  active: boolean;

  exclusive: boolean;

  halfExtent: SCNVector3;

  usesEllipsoidalExtent: boolean;

  scope: interop.Enum<typeof SCNPhysicsFieldScope>;

  offset: SCNVector3;

  direction: SCNVector3;

  categoryBitMask: number;

  static dragField(): SCNPhysicsField;

  static vortexField(): SCNPhysicsField;

  static radialGravityField(): SCNPhysicsField;

  static linearGravityField(): SCNPhysicsField;

  static noiseFieldWithSmoothnessAnimationSpeed(smoothness: number, speed: number): SCNPhysicsField;

  static turbulenceFieldWithSmoothnessAnimationSpeed(smoothness: number, speed: number): SCNPhysicsField;

  static springField(): SCNPhysicsField;

  static electricField(): SCNPhysicsField;

  static magneticField(): SCNPhysicsField;

  static customFieldWithEvaluationBlock(block: (p1: SCNVector3, p2: SCNVector3, p3: number, p4: number, p5: number) => SCNVector3): SCNPhysicsField;

  setStrength(strength: number): void;

  setFalloffExponent(falloffExponent: number): void;

  setMinimumDistance(minimumDistance: number): void;

  isActive(): boolean;

  setActive(active: boolean): void;

  isExclusive(): boolean;

  setExclusive(exclusive: boolean): void;

  setHalfExtent(halfExtent: SCNVector3): void;

  setUsesEllipsoidalExtent(usesEllipsoidalExtent: boolean): void;

  setScope(scope: interop.Enum<typeof SCNPhysicsFieldScope>): void;

  setOffset(offset: SCNVector3): void;

  setDirection(direction: SCNVector3): void;

  setCategoryBitMask(categoryBitMask: number): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNIKConstraint extends SCNConstraint {
  initWithChainRootNode(chainRootNode: SCNNode): this;

  static inverseKinematicsConstraintWithChainRootNode<This extends abstract new (...args: any) => any>(this: This, chainRootNode: SCNNode): InstanceType<This>;

  readonly chainRootNode: SCNNode;

  targetPosition: SCNVector3;

  setMaxAllowedRotationAngleForJoint(angle: number, node: SCNNode): void;

  maxAllowedRotationAngleForJoint(node: SCNNode): number;

  setTargetPosition(targetPosition: SCNVector3): void;
}

declare class SCNPhysicsBehavior extends NSObject implements NSSecureCoding {
  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNPhysicsVehicle extends SCNPhysicsBehavior {
  static vehicleWithChassisBodyWheels<This extends abstract new (...args: any) => any>(this: This, chassisBody: SCNPhysicsBody, wheels: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  readonly speedInKilometersPerHour: number;

  readonly wheels: NSArray;

  readonly chassisBody: SCNPhysicsBody;

  applyEngineForceForWheelAtIndex(value: number, index: number): void;

  setSteeringAngleForWheelAtIndex(value: number, index: number): void;

  applyBrakingForceForWheelAtIndex(value: number, index: number): void;
}

declare class SCNAudioPlayer extends NSObject {
  initWithSource(source: SCNAudioSource): this;

  initWithAVAudioNode(audioNode: AVAudioNode): this;

  static audioPlayerWithSource<This extends abstract new (...args: any) => any>(this: This, source: SCNAudioSource): InstanceType<This>;

  static audioPlayerWithAVAudioNode<This extends abstract new (...args: any) => any>(this: This, audioNode: AVAudioNode): InstanceType<This>;

  willStartPlayback: () => void;

  didFinishPlayback: () => void;

  readonly audioNode: AVAudioNode;

  readonly audioSource: SCNAudioSource;

  setWillStartPlayback(willStartPlayback: () => void | null): void;

  setDidFinishPlayback(didFinishPlayback: () => void | null): void;
}

declare class SCNPhysicsBallSocketJoint extends SCNPhysicsBehavior {
  static jointWithBodyAAnchorABodyBAnchorB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, anchorA: SCNVector3, bodyB: SCNPhysicsBody, anchorB: SCNVector3): InstanceType<This>;

  static jointWithBodyAnchor<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, anchor: SCNVector3): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  anchorA: SCNVector3;

  readonly bodyB: SCNPhysicsBody;

  anchorB: SCNVector3;

  setAnchorA(anchorA: SCNVector3): void;

  setAnchorB(anchorB: SCNVector3): void;
}

declare class SCNPhysicsHingeJoint extends SCNPhysicsBehavior {
  static jointWithBodyAAxisAAnchorABodyBAxisBAnchorB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3): InstanceType<This>;

  static jointWithBodyAxisAnchor<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  axisA: SCNVector3;

  anchorA: SCNVector3;

  readonly bodyB: SCNPhysicsBody;

  axisB: SCNVector3;

  anchorB: SCNVector3;

  setAxisA(axisA: SCNVector3): void;

  setAnchorA(anchorA: SCNVector3): void;

  setAxisB(axisB: SCNVector3): void;

  setAnchorB(anchorB: SCNVector3): void;
}

declare class SCNPhysicsShape extends NSObject implements NSCopying, NSSecureCoding {
  static shapeWithGeometryOptions<This extends abstract new (...args: any) => any>(this: This, geometry: SCNGeometry, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static shapeWithNodeOptions<This extends abstract new (...args: any) => any>(this: This, node: SCNNode, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static shapeWithShapesTransforms<This extends abstract new (...args: any) => any>(this: This, shapes: NSArray<interop.Object> | Array<interop.Object>, transforms: NSArray<interop.Object> | Array<interop.Object> | null): InstanceType<This>;

  readonly options: NSDictionary;

  readonly sourceObject: interop.Object;

  readonly transforms: NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNParticlePropertyController extends NSObject implements NSSecureCoding, NSCopying {
  static controllerWithAnimation<This extends abstract new (...args: any) => any>(this: This, animation: CAAnimation): InstanceType<This>;

  animation: CAAnimation;

  inputMode: interop.Enum<typeof SCNParticleInputMode>;

  inputScale: number;

  inputBias: number;

  inputOrigin: SCNNode;

  inputProperty: string;

  setAnimation(animation: CAAnimation): void;

  setInputMode(inputMode: interop.Enum<typeof SCNParticleInputMode>): void;

  setInputScale(inputScale: number): void;

  setInputBias(inputBias: number): void;

  setInputOrigin(inputOrigin: SCNNode | null): void;

  setInputProperty(inputProperty: string | null): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class SCNLookAtConstraint extends SCNConstraint {
  static lookAtConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  target: SCNNode;

  setTarget(target: SCNNode | null): void;

  targetOffset: SCNVector3;

  localFront: SCNVector3;

  worldUp: SCNVector3;

  gimbalLockEnabled: boolean;

  setTargetOffset(targetOffset: SCNVector3): void;

  setLocalFront(localFront: SCNVector3): void;

  setWorldUp(worldUp: SCNVector3): void;

  setGimbalLockEnabled(gimbalLockEnabled: boolean): void;
}

declare class SCNDistanceConstraint extends SCNConstraint {
  static distanceConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  target: SCNNode;

  minimumDistance: number;

  maximumDistance: number;

  setTarget(target: SCNNode | null): void;

  setMinimumDistance(minimumDistance: number): void;

  setMaximumDistance(maximumDistance: number): void;
}

declare class SCNConstraint extends NSObject implements NSCopying, NSSecureCoding, SCNAnimatable {
  enabled: boolean;

  influenceFactor: number;

  incremental: boolean;

  isEnabled(): boolean;

  setEnabled(enabled: boolean): void;

  setInfluenceFactor(influenceFactor: number): void;

  isIncremental(): boolean;

  setIncremental(incremental: boolean): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class SCNSkinner extends NSObject implements NSSecureCoding {
  skeleton: SCNNode;

  static skinnerWithBaseGeometryBonesBoneInverseBindTransformsBoneWeightsBoneIndices<This extends abstract new (...args: any) => any>(this: This, baseGeometry: SCNGeometry | null, bones: NSArray<interop.Object> | Array<interop.Object>, boneInverseBindTransforms: NSArray<interop.Object> | Array<interop.Object> | null, boneWeights: SCNGeometrySource, boneIndices: SCNGeometrySource): InstanceType<This>;

  baseGeometry: SCNGeometry;

  baseGeometryBindTransform: CATransform3D;

  readonly boneInverseBindTransforms: NSArray;

  readonly bones: NSArray;

  readonly boneWeights: SCNGeometrySource;

  readonly boneIndices: SCNGeometrySource;

  setSkeleton(skeleton: SCNNode | null): void;

  setBaseGeometry(baseGeometry: SCNGeometry): void;

  setBaseGeometryBindTransform(baseGeometryBindTransform: CATransform3D): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNText extends SCNGeometry {
  static textWithStringExtrusionDepth<This extends abstract new (...args: any) => any>(this: This, string: interop.Object | null, extrusionDepth: number): InstanceType<This>;

  extrusionDepth: number;

  string: interop.Object;

  font: NSFont;

  wrapped: boolean;

  containerFrame: CGRect;

  readonly textSize: CGSize;

  truncationMode: string;

  alignmentMode: string;

  chamferRadius: number;

  chamferSegmentCount: number;

  chamferProfile: NSBezierPath;

  flatness: number;

  setExtrusionDepth(extrusionDepth: number): void;

  setString(string: interop.Object | null): void;

  setFont(font: NSFont | null): void;

  isWrapped(): boolean;

  setWrapped(wrapped: boolean): void;

  setContainerFrame(containerFrame: CGRect): void;

  setTruncationMode(truncationMode: string): void;

  setAlignmentMode(alignmentMode: string): void;

  setChamferRadius(chamferRadius: number): void;

  setChamferSegmentCount(chamferSegmentCount: number): void;

  setChamferProfile(chamferProfile: NSBezierPath): void;

  setFlatness(flatness: number): void;
}

declare class SCNTube extends SCNGeometry {
  static tubeWithInnerRadiusOuterRadiusHeight<This extends abstract new (...args: any) => any>(this: This, innerRadius: number, outerRadius: number, height: number): InstanceType<This>;

  innerRadius: number;

  outerRadius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;

  setInnerRadius(innerRadius: number): void;

  setOuterRadius(outerRadius: number): void;

  setHeight(height: number): void;

  setRadialSegmentCount(radialSegmentCount: number): void;

  setHeightSegmentCount(heightSegmentCount: number): void;
}

declare class SCNCone extends SCNGeometry {
  static coneWithTopRadiusBottomRadiusHeight<This extends abstract new (...args: any) => any>(this: This, topRadius: number, bottomRadius: number, height: number): InstanceType<This>;

  topRadius: number;

  bottomRadius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;

  setTopRadius(topRadius: number): void;

  setBottomRadius(bottomRadius: number): void;

  setHeight(height: number): void;

  setRadialSegmentCount(radialSegmentCount: number): void;

  setHeightSegmentCount(heightSegmentCount: number): void;
}

declare class SCNBox extends SCNGeometry {
  static boxWithWidthHeightLengthChamferRadius<This extends abstract new (...args: any) => any>(this: This, width: number, height: number, length: number, chamferRadius: number): InstanceType<This>;

  width: number;

  height: number;

  length: number;

  chamferRadius: number;

  widthSegmentCount: number;

  heightSegmentCount: number;

  lengthSegmentCount: number;

  chamferSegmentCount: number;

  setWidth(width: number): void;

  setHeight(height: number): void;

  setLength(length: number): void;

  setChamferRadius(chamferRadius: number): void;

  setWidthSegmentCount(widthSegmentCount: number): void;

  setHeightSegmentCount(heightSegmentCount: number): void;

  setLengthSegmentCount(lengthSegmentCount: number): void;

  setChamferSegmentCount(chamferSegmentCount: number): void;
}

declare class SCNPlane extends SCNGeometry {
  static planeWithWidthHeight<This extends abstract new (...args: any) => any>(this: This, width: number, height: number): InstanceType<This>;

  width: number;

  height: number;

  widthSegmentCount: number;

  heightSegmentCount: number;

  cornerRadius: number;

  cornerSegmentCount: number;

  setWidth(width: number): void;

  setHeight(height: number): void;

  setWidthSegmentCount(widthSegmentCount: number): void;

  setHeightSegmentCount(heightSegmentCount: number): void;

  setCornerRadius(cornerRadius: number): void;

  setCornerSegmentCount(cornerSegmentCount: number): void;
}

declare class SCNPhysicsBody extends NSObject implements NSCopying, NSSecureCoding {
  static staticBody<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dynamicBody<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static kinematicBody<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static bodyWithTypeShape<This extends abstract new (...args: any) => any>(this: This, type: interop.Enum<typeof SCNPhysicsBodyType>, shape: SCNPhysicsShape | null): InstanceType<This>;

  type: interop.Enum<typeof SCNPhysicsBodyType>;

  mass: number;

  momentOfInertia: SCNVector3;

  usesDefaultMomentOfInertia: boolean;

  charge: number;

  friction: number;

  restitution: number;

  rollingFriction: number;

  physicsShape: SCNPhysicsShape;

  readonly isResting: boolean;

  allowsResting: boolean;

  velocity: SCNVector3;

  angularVelocity: SCNVector4;

  damping: number;

  angularDamping: number;

  velocityFactor: SCNVector3;

  angularVelocityFactor: SCNVector3;

  categoryBitMask: number;

  collisionBitMask: number;

  contactTestBitMask: number;

  affectedByGravity: boolean;

  applyForceImpulse(direction: SCNVector3, impulse: boolean): void;

  applyForceAtPositionImpulse(direction: SCNVector3, position: SCNVector3, impulse: boolean): void;

  applyTorqueImpulse(torque: SCNVector4, impulse: boolean): void;

  clearAllForces(): void;

  resetTransform(): void;

  setResting(resting: boolean): void;

  continuousCollisionDetectionThreshold: number;

  centerOfMassOffset: SCNVector3;

  linearRestingThreshold: number;

  angularRestingThreshold: number;

  setType(type: interop.Enum<typeof SCNPhysicsBodyType>): void;

  setMass(mass: number): void;

  setMomentOfInertia(momentOfInertia: SCNVector3): void;

  setUsesDefaultMomentOfInertia(usesDefaultMomentOfInertia: boolean): void;

  setCharge(charge: number): void;

  setFriction(friction: number): void;

  setRestitution(restitution: number): void;

  setRollingFriction(rollingFriction: number): void;

  setPhysicsShape(physicsShape: SCNPhysicsShape | null): void;

  setAllowsResting(allowsResting: boolean): void;

  setVelocity(velocity: SCNVector3): void;

  setAngularVelocity(angularVelocity: SCNVector4): void;

  setDamping(damping: number): void;

  setAngularDamping(angularDamping: number): void;

  setVelocityFactor(velocityFactor: SCNVector3): void;

  setAngularVelocityFactor(angularVelocityFactor: SCNVector3): void;

  setCategoryBitMask(categoryBitMask: number): void;

  setCollisionBitMask(collisionBitMask: number): void;

  setContactTestBitMask(contactTestBitMask: number): void;

  isAffectedByGravity(): boolean;

  setAffectedByGravity(affectedByGravity: boolean): void;

  setContinuousCollisionDetectionThreshold(continuousCollisionDetectionThreshold: number): void;

  setCenterOfMassOffset(centerOfMassOffset: SCNVector3): void;

  setLinearRestingThreshold(linearRestingThreshold: number): void;

  setAngularRestingThreshold(angularRestingThreshold: number): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNGeometryElement extends NSObject implements NSSecureCoding {
  static geometryElementWithDataPrimitiveTypePrimitiveCountBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, data: NSData | null, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, bytesPerIndex: number): InstanceType<This>;

  static geometryElementWithDataPrimitiveTypePrimitiveCountIndicesChannelCountInterleavedIndicesChannelsBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, data: NSData | null, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, indicesChannelCount: number, interleavedIndicesChannels: boolean, bytesPerIndex: number): InstanceType<This>;

  static geometryElementWithBufferPrimitiveTypePrimitiveCountBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, buffer: MTLBuffer, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, bytesPerIndex: number): InstanceType<This>;

  static geometryElementWithBufferPrimitiveTypePrimitiveCountIndicesChannelCountInterleavedIndicesChannelsBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, buffer: MTLBuffer, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, indicesChannelCount: number, interleavedIndicesChannels: boolean, bytesPerIndex: number): InstanceType<This>;

  readonly data: NSData;

  readonly primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>;

  readonly primitiveCount: number;

  readonly interleavedIndicesChannels: boolean;

  readonly indicesChannelCount: number;

  readonly bytesPerIndex: number;

  primitiveRange: _NSRange;

  pointSize: number;

  minimumPointScreenSpaceRadius: number;

  maximumPointScreenSpaceRadius: number;

  hasInterleavedIndicesChannels(): boolean;

  setPrimitiveRange(primitiveRange: _NSRange): void;

  setPointSize(pointSize: number): void;

  setMinimumPointScreenSpaceRadius(minimumPointScreenSpaceRadius: number): void;

  setMaximumPointScreenSpaceRadius(maximumPointScreenSpaceRadius: number): void;

  static geometryElementWithMDLSubmesh<This extends abstract new (...args: any) => any>(this: This, mdlSubMesh: MDLSubmesh): InstanceType<This>;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNGeometrySource extends NSObject implements NSSecureCoding {
  static geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride<This extends abstract new (...args: any) => any>(this: This, data: NSData, semantic: string, vectorCount: number, floatComponents: boolean, componentsPerVector: number, bytesPerComponent: number, offset: number, stride: number): InstanceType<This>;

  static geometrySourceWithVerticesCount<This extends abstract new (...args: any) => any>(this: This, vertices: interop.PointerConvertible, count: number): InstanceType<This>;

  static geometrySourceWithNormalsCount<This extends abstract new (...args: any) => any>(this: This, normals: interop.PointerConvertible, count: number): InstanceType<This>;

  static geometrySourceWithTextureCoordinatesCount<This extends abstract new (...args: any) => any>(this: This, texcoord: interop.PointerConvertible, count: number): InstanceType<This>;

  static geometrySourceWithBufferVertexFormatSemanticVertexCountDataOffsetDataStride<This extends abstract new (...args: any) => any>(this: This, buffer: MTLBuffer, vertexFormat: interop.Enum<typeof MTLVertexFormat>, semantic: string, vertexCount: number, offset: number, stride: number): InstanceType<This>;

  readonly data: NSData;

  readonly semantic: string;

  readonly vectorCount: number;

  readonly floatComponents: boolean;

  readonly componentsPerVector: number;

  readonly bytesPerComponent: number;

  readonly dataOffset: number;

  readonly dataStride: number;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNMaterial extends NSObject implements SCNAnimatable, SCNShadable, NSCopying, NSSecureCoding {
  static material<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  name: string;

  readonly diffuse: SCNMaterialProperty;

  readonly ambient: SCNMaterialProperty;

  readonly specular: SCNMaterialProperty;

  readonly emission: SCNMaterialProperty;

  readonly transparent: SCNMaterialProperty;

  readonly reflective: SCNMaterialProperty;

  readonly multiply: SCNMaterialProperty;

  readonly normal: SCNMaterialProperty;

  readonly displacement: SCNMaterialProperty;

  readonly ambientOcclusion: SCNMaterialProperty;

  readonly selfIllumination: SCNMaterialProperty;

  readonly metalness: SCNMaterialProperty;

  readonly roughness: SCNMaterialProperty;

  readonly clearCoat: SCNMaterialProperty;

  readonly clearCoatRoughness: SCNMaterialProperty;

  readonly clearCoatNormal: SCNMaterialProperty;

  shininess: number;

  transparency: number;

  lightingModelName: string;

  litPerPixel: boolean;

  doubleSided: boolean;

  fillMode: interop.Enum<typeof SCNFillMode>;

  cullMode: interop.Enum<typeof SCNCullMode>;

  transparencyMode: interop.Enum<typeof SCNTransparencyMode>;

  locksAmbientWithDiffuse: boolean;

  writesToDepthBuffer: boolean;

  colorBufferWriteMask: interop.Enum<typeof SCNColorMask>;

  readsFromDepthBuffer: boolean;

  fresnelExponent: number;

  blendMode: interop.Enum<typeof SCNBlendMode>;

  setName(name: string | null): void;

  setShininess(shininess: number): void;

  setTransparency(transparency: number): void;

  setLightingModelName(lightingModelName: string): void;

  isLitPerPixel(): boolean;

  setLitPerPixel(litPerPixel: boolean): void;

  isDoubleSided(): boolean;

  setDoubleSided(doubleSided: boolean): void;

  setFillMode(fillMode: interop.Enum<typeof SCNFillMode>): void;

  setCullMode(cullMode: interop.Enum<typeof SCNCullMode>): void;

  setTransparencyMode(transparencyMode: interop.Enum<typeof SCNTransparencyMode>): void;

  setLocksAmbientWithDiffuse(locksAmbientWithDiffuse: boolean): void;

  setWritesToDepthBuffer(writesToDepthBuffer: boolean): void;

  setColorBufferWriteMask(colorBufferWriteMask: interop.Enum<typeof SCNColorMask>): void;

  setReadsFromDepthBuffer(readsFromDepthBuffer: boolean): void;

  setFresnelExponent(fresnelExponent: number): void;

  setBlendMode(blendMode: interop.Enum<typeof SCNBlendMode>): void;

  static materialWithMDLMaterial<This extends abstract new (...args: any) => any>(this: This, mdlMaterial: MDLMaterial): InstanceType<This>;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  program: SCNProgram;

  handleBindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  handleUnbindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  get shaderModifiers(): NSDictionary;
  set shaderModifiers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  minimumLanguageVersion: NSNumber;

  setProgram(program: SCNProgram): void;

  setShaderModifiers(shaderModifiers: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  setMinimumLanguageVersion(minimumLanguageVersion: NSNumber | null): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNNode extends NSObject implements NSCopying, NSSecureCoding, SCNAnimatable, SCNActionable, SCNBoundingVolume {
  static node<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static nodeWithGeometry(geometry: SCNGeometry | null): SCNNode;

  clone(): this;

  flattenedClone(): this;

  name: string;

  light: SCNLight;

  camera: SCNCamera;

  geometry: SCNGeometry;

  skinner: SCNSkinner;

  morpher: SCNMorpher;

  transform: CATransform3D;

  readonly worldTransform: CATransform3D;

  setWorldTransform(worldTransform: CATransform3D): void;

  position: SCNVector3;

  worldPosition: SCNVector3;

  rotation: SCNVector4;

  orientation: SCNVector4;

  worldOrientation: SCNVector4;

  eulerAngles: SCNVector3;

  scale: SCNVector3;

  pivot: CATransform3D;

  hidden: boolean;

  opacity: number;

  renderingOrder: number;

  castsShadow: boolean;

  movabilityHint: interop.Enum<typeof SCNMovabilityHint>;

  readonly parentNode: SCNNode;

  readonly childNodes: NSArray;

  addChildNode(child: SCNNode): void;

  insertChildNodeAtIndex(child: SCNNode, index: number): void;

  removeFromParentNode(): void;

  replaceChildNodeWith(oldChild: SCNNode, newChild: SCNNode): void;

  childNodeWithNameRecursively(name: string, recursively: boolean): SCNNode;

  childNodesPassingTest(predicate: (p1: SCNNode, p2: interop.PointerConvertible) => boolean): NSArray;

  enumerateChildNodesUsingBlock(block: (p1: SCNNode, p2: interop.PointerConvertible) => void): void;

  enumerateHierarchyUsingBlock(block: (p1: SCNNode, p2: interop.PointerConvertible) => void): void;

  convertPositionToNode(position: SCNVector3, node: SCNNode | null): SCNVector3;

  convertPositionFromNode(position: SCNVector3, node: SCNNode | null): SCNVector3;

  convertVectorToNode(vector: SCNVector3, node: SCNNode | null): SCNVector3;

  convertVectorFromNode(vector: SCNVector3, node: SCNNode | null): SCNVector3;

  convertTransformToNode(transform: CATransform3D, node: SCNNode | null): CATransform3D;

  convertTransformFromNode(transform: CATransform3D, node: SCNNode | null): CATransform3D;

  physicsBody: SCNPhysicsBody;

  physicsField: SCNPhysicsField;

  get constraints(): NSArray;
  set constraints(value: NSArray<interop.Object> | Array<interop.Object>);

  get filters(): NSArray;
  set filters(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly presentationNode: SCNNode;

  paused: boolean;

  rendererDelegate: SCNNodeRendererDelegate;

  hitTestWithSegmentFromPointToPointOptions(pointA: SCNVector3, pointB: SCNVector3, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  categoryBitMask: number;

  setName(name: string | null): void;

  setLight(light: SCNLight | null): void;

  setCamera(camera: SCNCamera | null): void;

  setGeometry(geometry: SCNGeometry | null): void;

  setSkinner(skinner: SCNSkinner): void;

  setMorpher(morpher: SCNMorpher): void;

  setTransform(transform: CATransform3D): void;

  setPosition(position: SCNVector3): void;

  setWorldPosition(worldPosition: SCNVector3): void;

  setRotation(rotation: SCNVector4): void;

  setOrientation(orientation: SCNVector4): void;

  setWorldOrientation(worldOrientation: SCNVector4): void;

  setEulerAngles(eulerAngles: SCNVector3): void;

  setScale(scale: SCNVector3): void;

  setPivot(pivot: CATransform3D): void;

  isHidden(): boolean;

  setHidden(hidden: boolean): void;

  setOpacity(opacity: number): void;

  setRenderingOrder(renderingOrder: number): void;

  setCastsShadow(castsShadow: boolean): void;

  setMovabilityHint(movabilityHint: interop.Enum<typeof SCNMovabilityHint>): void;

  setPhysicsBody(physicsBody: SCNPhysicsBody): void;

  setPhysicsField(physicsField: SCNPhysicsField): void;

  setConstraints(constraints: NSArray<interop.Object> | Array<interop.Object>): void;

  setFilters(filters: NSArray<interop.Object> | Array<interop.Object>): void;

  isPaused(): boolean;

  setPaused(paused: boolean): void;

  setRendererDelegate(rendererDelegate: SCNNodeRendererDelegate | null): void;

  setCategoryBitMask(categoryBitMask: number): void;

  static readonly localUp: SCNVector3;

  static readonly localRight: SCNVector3;

  static readonly localFront: SCNVector3;

  readonly worldUp: SCNVector3;

  readonly worldRight: SCNVector3;

  readonly worldFront: SCNVector3;

  lookAt(worldTarget: SCNVector3): void;

  lookAtUpLocalFront(worldTarget: SCNVector3, worldUp: SCNVector3, localFront: SCNVector3): void;

  localTranslateBy(translation: SCNVector3): void;

  localRotateBy(rotation: SCNVector4): void;

  rotateByAroundTarget(worldRotation: SCNVector4, worldTarget: SCNVector3): void;

  simdTransform: simd_float4x4;

  simdPosition: unknown /* ext vector */;

  simdRotation: unknown /* ext vector */;

  simdOrientation: simd_quatf;

  simdEulerAngles: unknown /* ext vector */;

  simdScale: unknown /* ext vector */;

  simdPivot: simd_float4x4;

  simdWorldPosition: unknown /* ext vector */;

  simdWorldOrientation: simd_quatf;

  simdWorldTransform: simd_float4x4;

  simdConvertPositionToNode(position: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertPositionFromNode(position: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertVectorToNode(vector: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertVectorFromNode(vector: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertTransformToNode(transform: simd_float4x4, node: SCNNode | null): simd_float4x4;

  simdConvertTransformFromNode(transform: simd_float4x4, node: SCNNode | null): simd_float4x4;

  static readonly simdLocalUp: unknown /* ext vector */;

  static readonly simdLocalRight: unknown /* ext vector */;

  static readonly simdLocalFront: unknown /* ext vector */;

  readonly simdWorldUp: unknown /* ext vector */;

  readonly simdWorldRight: unknown /* ext vector */;

  readonly simdWorldFront: unknown /* ext vector */;

  simdLookAt(worldTarget: unknown /* ext vector */): void;

  simdLookAtUpLocalFront(worldTarget: unknown /* ext vector */, worldUp: unknown /* ext vector */, localFront: unknown /* ext vector */): void;

  simdLocalTranslateBy(translation: unknown /* ext vector */): void;

  simdLocalRotateBy(rotation: simd_quatf): void;

  simdRotateByAroundTarget(worldRotation: simd_quatf, worldTarget: unknown /* ext vector */): void;

  setSimdTransform(simdTransform: simd_float4x4): void;

  setSimdPosition(simdPosition: unknown /* ext vector */): void;

  setSimdRotation(simdRotation: unknown /* ext vector */): void;

  setSimdOrientation(simdOrientation: simd_quatf): void;

  setSimdEulerAngles(simdEulerAngles: unknown /* ext vector */): void;

  setSimdScale(simdScale: unknown /* ext vector */): void;

  setSimdPivot(simdPivot: simd_float4x4): void;

  setSimdWorldPosition(simdWorldPosition: unknown /* ext vector */): void;

  setSimdWorldOrientation(simdWorldOrientation: simd_quatf): void;

  setSimdWorldTransform(simdWorldTransform: simd_float4x4): void;

  focusBehavior: interop.Enum<typeof SCNNodeFocusBehavior>;

  setFocusBehavior(focusBehavior: interop.Enum<typeof SCNNodeFocusBehavior>): void;

  addParticleSystem(system: SCNParticleSystem): void;

  removeAllParticleSystems(): void;

  removeParticleSystem(system: SCNParticleSystem): void;

  readonly particleSystems: NSArray;

  addAudioPlayer(player: SCNAudioPlayer): void;

  removeAllAudioPlayers(): void;

  removeAudioPlayer(player: SCNAudioPlayer): void;

  readonly audioPlayers: NSArray;

  entity: GKEntity;

  setEntity(entity: GKEntity): void;

  static nodeWithMDLObject<This extends abstract new (...args: any) => any>(this: This, mdlObject: MDLObject): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  runAction(action: SCNAction): void;

  runActionCompletionHandler(action: SCNAction, block: () => void | null): void;

  runActionForKey(action: SCNAction, key: string | null): void;

  runActionForKeyCompletionHandler(action: SCNAction, key: string | null, block: () => void | null): void;

  readonly hasActions: boolean;

  actionForKey(key: string): SCNAction;

  removeActionForKey(key: string): void;

  removeAllActions(): void;

  readonly actionKeys: NSArray;

  getBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): boolean;

  setBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): void;

  getBoundingSphereCenterRadius(center: interop.PointerConvertible, radius: interop.PointerConvertible): boolean;
}

declare class SCNAction extends NSObject implements NSCopying, NSSecureCoding {
  duration: number;

  timingMode: interop.Enum<typeof SCNActionTimingMode>;

  timingFunction: (p1: number) => number;

  speed: number;

  reversedAction(): SCNAction;

  static moveByXYZDuration(deltaX: number, deltaY: number, deltaZ: number, duration: number): SCNAction;

  static moveByDuration(delta: SCNVector3, duration: number): SCNAction;

  static moveToDuration(location: SCNVector3, duration: number): SCNAction;

  static rotateByXYZDuration(xAngle: number, yAngle: number, zAngle: number, duration: number): SCNAction;

  static rotateToXYZDuration(xAngle: number, yAngle: number, zAngle: number, duration: number): SCNAction;

  static rotateToXYZDurationShortestUnitArc(xAngle: number, yAngle: number, zAngle: number, duration: number, shortestUnitArc: boolean): SCNAction;

  static rotateByAngleAroundAxisDuration(angle: number, axis: SCNVector3, duration: number): SCNAction;

  static rotateToAxisAngleDuration(axisAngle: SCNVector4, duration: number): SCNAction;

  static scaleByDuration(scale: number, sec: number): SCNAction;

  static scaleToDuration(scale: number, sec: number): SCNAction;

  static sequence(actions: NSArray<interop.Object> | Array<interop.Object>): SCNAction;

  static group(actions: NSArray<interop.Object> | Array<interop.Object>): SCNAction;

  static repeatActionCount(action: SCNAction, count: number): SCNAction;

  static repeatActionForever(action: SCNAction): SCNAction;

  static fadeInWithDuration(sec: number): SCNAction;

  static fadeOutWithDuration(sec: number): SCNAction;

  static fadeOpacityByDuration(factor: number, sec: number): SCNAction;

  static fadeOpacityToDuration(opacity: number, sec: number): SCNAction;

  static hide(): SCNAction;

  static unhide(): SCNAction;

  static waitForDuration(sec: number): SCNAction;

  static waitForDurationWithRange(sec: number, durationRange: number): SCNAction;

  static removeFromParentNode(): SCNAction;

  static runBlock(block: (p1: SCNNode) => void): SCNAction;

  static runBlockQueue(block: (p1: SCNNode) => void, queue: NSObject): SCNAction;

  static javaScriptActionWithScriptDuration(script: string, seconds: number): SCNAction;

  static customActionWithDurationActionBlock(seconds: number, block: (p1: SCNNode, p2: number) => void): SCNAction;

  static playAudioSourceWaitForCompletion(source: SCNAudioSource, wait: boolean): SCNAction;

  setDuration(duration: number): void;

  setTimingMode(timingMode: interop.Enum<typeof SCNActionTimingMode>): void;

  setTimingFunction(timingFunction: (p1: number) => number | null): void;

  setSpeed(speed: number): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNView extends NSView implements SCNSceneRenderer, SCNTechniqueSupport {
  initWithFrameOptions(frame: CGRect, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  scene: SCNScene;

  rendersContinuously: boolean;

  backgroundColor: NSColor;

  allowsCameraControl: boolean;

  readonly cameraControlConfiguration: SCNCameraControlConfiguration;

  readonly defaultCameraController: SCNCameraController;

  snapshot(): NSImage;

  play(sender: interop.Object | null): void;

  pause(sender: interop.Object | null): void;

  stop(sender: interop.Object | null): void;

  preferredFramesPerSecond: number;

  drawableResizesAsynchronously: boolean;

  openGLContext: NSOpenGLContext;

  antialiasingMode: interop.Enum<typeof SCNAntialiasingMode>;

  pixelFormat: NSOpenGLPixelFormat;

  setScene(scene: SCNScene | null): void;

  setRendersContinuously(rendersContinuously: boolean): void;

  setBackgroundColor(backgroundColor: NSColor): void;

  setAllowsCameraControl(allowsCameraControl: boolean): void;

  setPreferredFramesPerSecond(preferredFramesPerSecond: number): void;

  setDrawableResizesAsynchronously(drawableResizesAsynchronously: boolean): void;

  setOpenGLContext(openGLContext: NSOpenGLContext): void;

  setAntialiasingMode(antialiasingMode: interop.Enum<typeof SCNAntialiasingMode>): void;

  setPixelFormat(pixelFormat: NSOpenGLPixelFormat): void;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  playing: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  jitteringEnabled: boolean;

  temporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;

  setSceneTime(sceneTime: number): void;

  setDelegate(delegate: SCNSceneRendererDelegate | null): void;

  isPlaying(): boolean;

  setPlaying(playing: boolean): void;

  setLoops(loops: boolean): void;

  setPointOfView(pointOfView: SCNNode | null): void;

  setAutoenablesDefaultLighting(autoenablesDefaultLighting: boolean): void;

  isJitteringEnabled(): boolean;

  setJitteringEnabled(jitteringEnabled: boolean): void;

  isTemporalAntialiasingEnabled(): boolean;

  setTemporalAntialiasingEnabled(temporalAntialiasingEnabled: boolean): void;

  setShowsStatistics(showsStatistics: boolean): void;

  setDebugOptions(debugOptions: interop.Enum<typeof SCNDebugOptions>): void;

  setOverlaySKScene(overlaySKScene: SKScene): void;

  setAudioListener(audioListener: SCNNode | null): void;

  setCurrentTime(currentTime: number): void;

  setUsesReverseZ(usesReverseZ: boolean): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;

  setTechnique(technique: SCNTechnique): void;
}

declare class SCNAnimationPlayer extends NSObject implements SCNAnimatable, NSCopying, NSSecureCoding {
  static animationPlayerWithAnimation(animation: SCNAnimation): SCNAnimationPlayer;

  readonly animation: SCNAnimation;

  speed: number;

  blendFactor: number;

  paused: boolean;

  play(): void;

  stop(): void;

  stopWithBlendOutDuration(duration: number): void;

  setSpeed(speed: number): void;

  setBlendFactor(blendFactor: number): void;

  setPaused(paused: boolean): void;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNAnimation extends NSObject implements SCNAnimationProtocol, NSCopying, NSSecureCoding {
  static animationWithContentsOfURL(animationUrl: NSURL): SCNAnimation;

  static animationNamed(animationName: string): SCNAnimation;

  static animationWithCAAnimation(caAnimation: CAAnimation): SCNAnimation;

  duration: number;

  keyPath: string;

  timingFunction: SCNTimingFunction;

  blendInDuration: number;

  blendOutDuration: number;

  removedOnCompletion: boolean;

  appliedOnCompletion: boolean;

  repeatCount: number;

  autoreverses: boolean;

  startDelay: number;

  timeOffset: number;

  fillsForward: boolean;

  fillsBackward: boolean;

  usesSceneTimeBase: boolean;

  animationDidStart: (p1: SCNAnimation, p2: SCNAnimatable) => void;

  animationDidStop: (p1: SCNAnimation, p2: SCNAnimatable, p3: boolean) => void;

  get animationEvents(): NSArray;
  set animationEvents(value: NSArray<interop.Object> | Array<interop.Object>);

  additive: boolean;

  cumulative: boolean;

  setDuration(duration: number): void;

  setKeyPath(keyPath: string | null): void;

  setTimingFunction(timingFunction: SCNTimingFunction): void;

  setBlendInDuration(blendInDuration: number): void;

  setBlendOutDuration(blendOutDuration: number): void;

  isRemovedOnCompletion(): boolean;

  setRemovedOnCompletion(removedOnCompletion: boolean): void;

  isAppliedOnCompletion(): boolean;

  setAppliedOnCompletion(appliedOnCompletion: boolean): void;

  setRepeatCount(repeatCount: number): void;

  setAutoreverses(autoreverses: boolean): void;

  setStartDelay(startDelay: number): void;

  setTimeOffset(timeOffset: number): void;

  setFillsForward(fillsForward: boolean): void;

  setFillsBackward(fillsBackward: boolean): void;

  setUsesSceneTimeBase(usesSceneTimeBase: boolean): void;

  setAnimationDidStart(animationDidStart: (p1: SCNAnimation, p2: SCNAnimatable) => void | null): void;

  setAnimationDidStop(animationDidStop: (p1: SCNAnimation, p2: SCNAnimatable, p3: boolean) => void | null): void;

  setAnimationEvents(animationEvents: NSArray<interop.Object> | Array<interop.Object> | null): void;

  isAdditive(): boolean;

  setAdditive(additive: boolean): void;

  isCumulative(): boolean;

  setCumulative(cumulative: boolean): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNTimingFunction extends NSObject implements NSSecureCoding {
  static functionWithTimingMode(timingMode: interop.Enum<typeof SCNActionTimingMode>): SCNTimingFunction;

  static functionWithCAMediaTimingFunction(caTimingFunction: CAMediaTimingFunction): SCNTimingFunction;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNFloor extends SCNGeometry {
  static floor<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  reflectivity: number;

  reflectionFalloffStart: number;

  reflectionFalloffEnd: number;

  reflectionCategoryBitMask: number;

  width: number;

  length: number;

  reflectionResolutionScaleFactor: number;

  setReflectivity(reflectivity: number): void;

  setReflectionFalloffStart(reflectionFalloffStart: number): void;

  setReflectionFalloffEnd(reflectionFalloffEnd: number): void;

  setReflectionCategoryBitMask(reflectionCategoryBitMask: number): void;

  setWidth(width: number): void;

  setLength(length: number): void;

  setReflectionResolutionScaleFactor(reflectionResolutionScaleFactor: number): void;
}

declare class SCNPhysicsConeTwistJoint extends SCNPhysicsBehavior {
  static jointWithBodyAFrameABodyBFrameB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, frameA: CATransform3D, bodyB: SCNPhysicsBody, frameB: CATransform3D): InstanceType<This>;

  static jointWithBodyFrame<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, frame: CATransform3D): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  frameA: CATransform3D;

  readonly bodyB: SCNPhysicsBody;

  frameB: CATransform3D;

  maximumAngularLimit1: number;

  maximumAngularLimit2: number;

  maximumTwistAngle: number;

  setFrameA(frameA: CATransform3D): void;

  setFrameB(frameB: CATransform3D): void;

  setMaximumAngularLimit1(maximumAngularLimit1: number): void;

  setMaximumAngularLimit2(maximumAngularLimit2: number): void;

  setMaximumTwistAngle(maximumTwistAngle: number): void;
}

declare class SCNAvoidOccluderConstraint extends SCNConstraint {
  static avoidOccluderConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  delegate: SCNAvoidOccluderConstraintDelegate;

  target: SCNNode;

  occluderCategoryBitMask: number;

  bias: number;

  setDelegate(delegate: SCNAvoidOccluderConstraintDelegate): void;

  setTarget(target: SCNNode | null): void;

  setOccluderCategoryBitMask(occluderCategoryBitMask: number): void;

  setBias(bias: number): void;
}

declare class SCNHitTestResult extends NSObject {
  readonly node: SCNNode;

  readonly geometryIndex: number;

  readonly faceIndex: number;

  readonly localCoordinates: SCNVector3;

  readonly worldCoordinates: SCNVector3;

  readonly localNormal: SCNVector3;

  readonly worldNormal: SCNVector3;

  readonly modelTransform: CATransform3D;

  readonly boneNode: SCNNode;

  textureCoordinatesWithMappingChannel(channel: number): CGPoint;

  readonly simdLocalCoordinates: unknown /* ext vector */;

  readonly simdWorldCoordinates: unknown /* ext vector */;

  readonly simdLocalNormal: unknown /* ext vector */;

  readonly simdWorldNormal: unknown /* ext vector */;

  readonly simdModelTransform: simd_float4x4;
}

declare class SCNCylinder extends SCNGeometry {
  static cylinderWithRadiusHeight<This extends abstract new (...args: any) => any>(this: This, radius: number, height: number): InstanceType<This>;

  radius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;

  setRadius(radius: number): void;

  setHeight(height: number): void;

  setRadialSegmentCount(radialSegmentCount: number): void;

  setHeightSegmentCount(heightSegmentCount: number): void;
}

declare class SCNAudioSource extends NSObject implements NSCopying, NSSecureCoding {
  initWithFileNamed(name: string): this;

  initWithURL(url: NSURL): this;

  static audioSourceNamed<This extends abstract new (...args: any) => any>(this: This, fileName: string): InstanceType<This>;

  positional: boolean;

  volume: number;

  rate: number;

  reverbBlend: number;

  loops: boolean;

  shouldStream: boolean;

  load(): void;

  isPositional(): boolean;

  setPositional(positional: boolean): void;

  setVolume(volume: number): void;

  setRate(rate: number): void;

  setReverbBlend(reverbBlend: number): void;

  setLoops(loops: boolean): void;

  setShouldStream(shouldStream: boolean): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNAccelerationConstraint extends SCNConstraint {
  static accelerationConstraint<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  maximumLinearAcceleration: number;

  maximumLinearVelocity: number;

  decelerationDistance: number;

  damping: number;

  setMaximumLinearAcceleration(maximumLinearAcceleration: number): void;

  setMaximumLinearVelocity(maximumLinearVelocity: number): void;

  setDecelerationDistance(decelerationDistance: number): void;

  setDamping(damping: number): void;
}

declare class SCNAnimationEvent extends NSObject {
  static animationEventWithKeyTimeBlock<This extends abstract new (...args: any) => any>(this: This, time: number, eventBlock: (p1: SCNAnimation, p2: interop.Object, p3: boolean) => void): InstanceType<This>;
}

declare class SCNPhysicsSliderJoint extends SCNPhysicsBehavior {
  static jointWithBodyAAxisAAnchorABodyBAxisBAnchorB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3): InstanceType<This>;

  static jointWithBodyAxisAnchor<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  axisA: SCNVector3;

  anchorA: SCNVector3;

  readonly bodyB: SCNPhysicsBody;

  axisB: SCNVector3;

  anchorB: SCNVector3;

  minimumLinearLimit: number;

  maximumLinearLimit: number;

  minimumAngularLimit: number;

  maximumAngularLimit: number;

  motorTargetLinearVelocity: number;

  motorMaximumForce: number;

  motorTargetAngularVelocity: number;

  motorMaximumTorque: number;

  setAxisA(axisA: SCNVector3): void;

  setAnchorA(anchorA: SCNVector3): void;

  setAxisB(axisB: SCNVector3): void;

  setAnchorB(anchorB: SCNVector3): void;

  setMinimumLinearLimit(minimumLinearLimit: number): void;

  setMaximumLinearLimit(maximumLinearLimit: number): void;

  setMinimumAngularLimit(minimumAngularLimit: number): void;

  setMaximumAngularLimit(maximumAngularLimit: number): void;

  setMotorTargetLinearVelocity(motorTargetLinearVelocity: number): void;

  setMotorMaximumForce(motorMaximumForce: number): void;

  setMotorTargetAngularVelocity(motorTargetAngularVelocity: number): void;

  setMotorMaximumTorque(motorMaximumTorque: number): void;
}

declare class SCNGeometry extends NSObject implements SCNAnimatable, SCNBoundingVolume, SCNShadable, NSCopying, NSSecureCoding {
  static geometry<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  name: string;

  get materials(): NSArray;
  set materials(value: NSArray<interop.Object> | Array<interop.Object>);

  firstMaterial: SCNMaterial;

  insertMaterialAtIndex(material: SCNMaterial, index: number): void;

  removeMaterialAtIndex(index: number): void;

  replaceMaterialAtIndexWithMaterial(index: number, material: SCNMaterial): void;

  materialWithName(name: string): SCNMaterial;

  static geometryWithSourcesElements<This extends abstract new (...args: any) => any>(this: This, sources: NSArray<interop.Object> | Array<interop.Object>, elements: NSArray<interop.Object> | Array<interop.Object> | null): InstanceType<This>;

  static geometryWithSourcesElementsSourceChannels<This extends abstract new (...args: any) => any>(this: This, sources: NSArray<interop.Object> | Array<interop.Object>, elements: NSArray<interop.Object> | Array<interop.Object> | null, sourceChannels: NSArray<interop.Object> | Array<interop.Object> | null): InstanceType<This>;

  readonly geometrySources: NSArray;

  geometrySourcesForSemantic(semantic: string): NSArray;

  readonly geometryElements: NSArray;

  readonly geometryElementCount: number;

  geometryElementAtIndex(elementIndex: number): SCNGeometryElement;

  readonly geometrySourceChannels: NSArray;

  get levelsOfDetail(): NSArray;
  set levelsOfDetail(value: NSArray<interop.Object> | Array<interop.Object>);

  tessellator: SCNGeometryTessellator;

  subdivisionLevel: number;

  wantsAdaptiveSubdivision: boolean;

  edgeCreasesElement: SCNGeometryElement;

  edgeCreasesSource: SCNGeometrySource;

  setName(name: string | null): void;

  setMaterials(materials: NSArray<interop.Object> | Array<interop.Object>): void;

  setFirstMaterial(firstMaterial: SCNMaterial | null): void;

  setLevelsOfDetail(levelsOfDetail: NSArray<interop.Object> | Array<interop.Object>): void;

  setTessellator(tessellator: SCNGeometryTessellator): void;

  setSubdivisionLevel(subdivisionLevel: number): void;

  setWantsAdaptiveSubdivision(wantsAdaptiveSubdivision: boolean): void;

  setEdgeCreasesElement(edgeCreasesElement: SCNGeometryElement): void;

  setEdgeCreasesSource(edgeCreasesSource: SCNGeometrySource): void;

  static geometryWithMDLMesh<This extends abstract new (...args: any) => any>(this: This, mdlMesh: MDLMesh): InstanceType<This>;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  getBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): boolean;

  setBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): void;

  getBoundingSphereCenterRadius(center: interop.PointerConvertible, radius: interop.PointerConvertible): boolean;

  program: SCNProgram;

  handleBindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  handleUnbindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  get shaderModifiers(): NSDictionary;
  set shaderModifiers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  minimumLanguageVersion: NSNumber;

  setProgram(program: SCNProgram): void;

  setShaderModifiers(shaderModifiers: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  setMinimumLanguageVersion(minimumLanguageVersion: NSNumber | null): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNTorus extends SCNGeometry {
  static torusWithRingRadiusPipeRadius<This extends abstract new (...args: any) => any>(this: This, ringRadius: number, pipeRadius: number): InstanceType<This>;

  ringRadius: number;

  pipeRadius: number;

  ringSegmentCount: number;

  pipeSegmentCount: number;

  setRingRadius(ringRadius: number): void;

  setPipeRadius(pipeRadius: number): void;

  setRingSegmentCount(ringSegmentCount: number): void;

  setPipeSegmentCount(pipeSegmentCount: number): void;
}

declare class SCNLight extends NSObject implements SCNAnimatable, NSCopying, NSSecureCoding {
  static light<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  type: string;

  color: interop.Object;

  temperature: number;

  intensity: number;

  name: string;

  castsShadow: boolean;

  shadowColor: interop.Object;

  shadowRadius: number;

  shadowMapSize: CGSize;

  shadowSampleCount: number;

  shadowMode: interop.Enum<typeof SCNShadowMode>;

  shadowBias: number;

  automaticallyAdjustsShadowProjection: boolean;

  maximumShadowDistance: number;

  forcesBackFaceCasters: boolean;

  sampleDistributedShadowMaps: boolean;

  shadowCascadeCount: number;

  shadowCascadeSplittingFactor: number;

  orthographicScale: number;

  zNear: number;

  zFar: number;

  attenuationStartDistance: number;

  attenuationEndDistance: number;

  attenuationFalloffExponent: number;

  spotInnerAngle: number;

  spotOuterAngle: number;

  IESProfileURL: NSURL;

  readonly sphericalHarmonicsCoefficients: NSData;

  probeType: interop.Enum<typeof SCNLightProbeType>;

  probeUpdateType: interop.Enum<typeof SCNLightProbeUpdateType>;

  probeExtents: unknown /* ext vector */;

  probeOffset: unknown /* ext vector */;

  parallaxCorrectionEnabled: boolean;

  parallaxExtentsFactor: unknown /* ext vector */;

  parallaxCenterOffset: unknown /* ext vector */;

  readonly probeEnvironment: SCNMaterialProperty;

  areaType: interop.Enum<typeof SCNLightAreaType>;

  areaExtents: unknown /* ext vector */;

  get areaPolygonVertices(): NSArray;
  set areaPolygonVertices(value: NSArray<interop.Object> | Array<interop.Object>);

  drawsArea: boolean;

  doubleSided: boolean;

  readonly gobo: SCNMaterialProperty;

  categoryBitMask: number;

  setType(type: string): void;

  setColor(color: interop.Object): void;

  setTemperature(temperature: number): void;

  setIntensity(intensity: number): void;

  setName(name: string | null): void;

  setCastsShadow(castsShadow: boolean): void;

  setShadowColor(shadowColor: interop.Object): void;

  setShadowRadius(shadowRadius: number): void;

  setShadowMapSize(shadowMapSize: CGSize): void;

  setShadowSampleCount(shadowSampleCount: number): void;

  setShadowMode(shadowMode: interop.Enum<typeof SCNShadowMode>): void;

  setShadowBias(shadowBias: number): void;

  setAutomaticallyAdjustsShadowProjection(automaticallyAdjustsShadowProjection: boolean): void;

  setMaximumShadowDistance(maximumShadowDistance: number): void;

  setForcesBackFaceCasters(forcesBackFaceCasters: boolean): void;

  setSampleDistributedShadowMaps(sampleDistributedShadowMaps: boolean): void;

  setShadowCascadeCount(shadowCascadeCount: number): void;

  setShadowCascadeSplittingFactor(shadowCascadeSplittingFactor: number): void;

  setOrthographicScale(orthographicScale: number): void;

  setZNear(zNear: number): void;

  setZFar(zFar: number): void;

  setAttenuationStartDistance(attenuationStartDistance: number): void;

  setAttenuationEndDistance(attenuationEndDistance: number): void;

  setAttenuationFalloffExponent(attenuationFalloffExponent: number): void;

  setSpotInnerAngle(spotInnerAngle: number): void;

  setSpotOuterAngle(spotOuterAngle: number): void;

  setIESProfileURL(IESProfileURL: NSURL | null): void;

  setProbeType(probeType: interop.Enum<typeof SCNLightProbeType>): void;

  setProbeUpdateType(probeUpdateType: interop.Enum<typeof SCNLightProbeUpdateType>): void;

  setProbeExtents(probeExtents: unknown /* ext vector */): void;

  setProbeOffset(probeOffset: unknown /* ext vector */): void;

  setParallaxCorrectionEnabled(parallaxCorrectionEnabled: boolean): void;

  setParallaxExtentsFactor(parallaxExtentsFactor: unknown /* ext vector */): void;

  setParallaxCenterOffset(parallaxCenterOffset: unknown /* ext vector */): void;

  setAreaType(areaType: interop.Enum<typeof SCNLightAreaType>): void;

  setAreaExtents(areaExtents: unknown /* ext vector */): void;

  setAreaPolygonVertices(areaPolygonVertices: NSArray<interop.Object> | Array<interop.Object> | null): void;

  setDrawsArea(drawsArea: boolean): void;

  setDoubleSided(doubleSided: boolean): void;

  setCategoryBitMask(categoryBitMask: number): void;

  attributeForKey(key: string): interop.Object;

  setAttributeForKey(attribute: interop.Object | null, key: string): void;

  static lightWithMDLLight<This extends abstract new (...args: any) => any>(this: This, mdlLight: MDLLight): InstanceType<This>;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNMorpher extends NSObject implements SCNAnimatable, NSSecureCoding {
  get targets(): NSArray;
  set targets(value: NSArray<interop.Object> | Array<interop.Object>);

  get weights(): NSArray;
  set weights(value: NSArray<interop.Object> | Array<interop.Object>);

  setWeightForTargetAtIndex(weight: number, targetIndex: number): void;

  weightForTargetAtIndex(targetIndex: number): number;

  setWeightForTargetNamed(weight: number, targetName: string): void;

  weightForTargetNamed(targetName: string): number;

  calculationMode: interop.Enum<typeof SCNMorpherCalculationMode>;

  unifiesNormals: boolean;

  setTargets(targets: NSArray<interop.Object> | Array<interop.Object>): void;

  setWeights(weights: NSArray<interop.Object> | Array<interop.Object>): void;

  setCalculationMode(calculationMode: interop.Enum<typeof SCNMorpherCalculationMode>): void;

  setUnifiesNormals(unifiesNormals: boolean): void;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNBillboardConstraint extends SCNConstraint {
  static billboardConstraint<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  freeAxes: interop.Enum<typeof SCNBillboardAxis>;

  setFreeAxes(freeAxes: interop.Enum<typeof SCNBillboardAxis>): void;
}

declare class SCNRenderer extends NSObject implements SCNSceneRenderer, SCNTechniqueSupport {
  static rendererWithContextOptions<This extends abstract new (...args: any) => any>(this: This, context: interop.PointerConvertible, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static rendererWithDeviceOptions<This extends abstract new (...args: any) => any>(this: This, device: MTLDevice | null, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  scene: SCNScene;

  renderAtTimeViewportCommandBufferPassDescriptor(time: number, viewport: CGRect, commandBuffer: MTLCommandBuffer, renderPassDescriptor: MTLRenderPassDescriptor): void;

  renderAtTime(time: number): void;

  updateAtTime(time: number): void;

  renderWithViewportCommandBufferPassDescriptor(viewport: CGRect, commandBuffer: MTLCommandBuffer, renderPassDescriptor: MTLRenderPassDescriptor): void;

  readonly nextFrameTime: number;

  snapshotAtTimeWithSizeAntialiasingMode(time: number, size: CGSize, antialiasingMode: interop.Enum<typeof SCNAntialiasingMode>): NSImage;

  updateProbesAtTime(lightProbes: NSArray<interop.Object> | Array<interop.Object>, time: number): void;

  setScene(scene: SCNScene | null): void;

  render(): void;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  playing: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  jitteringEnabled: boolean;

  temporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;

  setSceneTime(sceneTime: number): void;

  setDelegate(delegate: SCNSceneRendererDelegate | null): void;

  isPlaying(): boolean;

  setPlaying(playing: boolean): void;

  setLoops(loops: boolean): void;

  setPointOfView(pointOfView: SCNNode | null): void;

  setAutoenablesDefaultLighting(autoenablesDefaultLighting: boolean): void;

  isJitteringEnabled(): boolean;

  setJitteringEnabled(jitteringEnabled: boolean): void;

  isTemporalAntialiasingEnabled(): boolean;

  setTemporalAntialiasingEnabled(temporalAntialiasingEnabled: boolean): void;

  setShowsStatistics(showsStatistics: boolean): void;

  setDebugOptions(debugOptions: interop.Enum<typeof SCNDebugOptions>): void;

  setOverlaySKScene(overlaySKScene: SKScene): void;

  setAudioListener(audioListener: SCNNode | null): void;

  setCurrentTime(currentTime: number): void;

  setUsesReverseZ(usesReverseZ: boolean): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;

  setTechnique(technique: SCNTechnique): void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class SCNLayer extends CAOpenGLLayer implements SCNSceneRenderer, SCNTechniqueSupport {
  scene: SCNScene;

  setScene(scene: SCNScene | null): void;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  // @ts-ignore MemberDecl.tsIgnore
  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  playing: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  jitteringEnabled: boolean;

  temporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;

  setSceneTime(sceneTime: number): void;

  // @ts-ignore MemberDecl.tsIgnore
  setDelegate(delegate: SCNSceneRendererDelegate | null): void;

  isPlaying(): boolean;

  setPlaying(playing: boolean): void;

  setLoops(loops: boolean): void;

  setPointOfView(pointOfView: SCNNode | null): void;

  setAutoenablesDefaultLighting(autoenablesDefaultLighting: boolean): void;

  isJitteringEnabled(): boolean;

  setJitteringEnabled(jitteringEnabled: boolean): void;

  isTemporalAntialiasingEnabled(): boolean;

  setTemporalAntialiasingEnabled(temporalAntialiasingEnabled: boolean): void;

  setShowsStatistics(showsStatistics: boolean): void;

  setDebugOptions(debugOptions: interop.Enum<typeof SCNDebugOptions>): void;

  setOverlaySKScene(overlaySKScene: SKScene): void;

  setAudioListener(audioListener: SCNNode | null): void;

  setCurrentTime(currentTime: number): void;

  setUsesReverseZ(usesReverseZ: boolean): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;

  setTechnique(technique: SCNTechnique): void;
}

declare class SCNCamera extends NSObject implements SCNAnimatable, SCNTechniqueSupport, NSCopying, NSSecureCoding {
  static camera<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  name: string;

  fieldOfView: number;

  projectionDirection: interop.Enum<typeof SCNCameraProjectionDirection>;

  focalLength: number;

  sensorHeight: number;

  zNear: number;

  zFar: number;

  automaticallyAdjustsZRange: boolean;

  usesOrthographicProjection: boolean;

  orthographicScale: number;

  projectionTransform: CATransform3D;

  setProjectionTransform(projectionTransform: CATransform3D): void;

  projectionTransformWithViewportSize(viewportSize: CGSize): CATransform3D;

  wantsDepthOfField: boolean;

  focusDistance: number;

  focalBlurSampleCount: number;

  fStop: number;

  apertureBladeCount: number;

  motionBlurIntensity: number;

  screenSpaceAmbientOcclusionIntensity: number;

  screenSpaceAmbientOcclusionRadius: number;

  screenSpaceAmbientOcclusionBias: number;

  screenSpaceAmbientOcclusionDepthThreshold: number;

  screenSpaceAmbientOcclusionNormalThreshold: number;

  wantsHDR: boolean;

  exposureOffset: number;

  averageGray: number;

  whitePoint: number;

  wantsExposureAdaptation: boolean;

  exposureAdaptationBrighteningSpeedFactor: number;

  exposureAdaptationDarkeningSpeedFactor: number;

  minimumExposure: number;

  maximumExposure: number;

  bloomThreshold: number;

  bloomIterationCount: number;

  bloomIterationSpread: number;

  bloomIntensity: number;

  bloomBlurRadius: number;

  vignettingPower: number;

  vignettingIntensity: number;

  colorFringeStrength: number;

  colorFringeIntensity: number;

  saturation: number;

  contrast: number;

  grainIntensity: number;

  grainScale: number;

  grainIsColored: boolean;

  whiteBalanceTemperature: number;

  whiteBalanceTint: number;

  readonly colorGrading: SCNMaterialProperty;

  categoryBitMask: number;

  setName(name: string | null): void;

  setFieldOfView(fieldOfView: number): void;

  setProjectionDirection(projectionDirection: interop.Enum<typeof SCNCameraProjectionDirection>): void;

  setFocalLength(focalLength: number): void;

  setSensorHeight(sensorHeight: number): void;

  setZNear(zNear: number): void;

  setZFar(zFar: number): void;

  setAutomaticallyAdjustsZRange(automaticallyAdjustsZRange: boolean): void;

  setUsesOrthographicProjection(usesOrthographicProjection: boolean): void;

  setOrthographicScale(orthographicScale: number): void;

  setWantsDepthOfField(wantsDepthOfField: boolean): void;

  setFocusDistance(focusDistance: number): void;

  setFocalBlurSampleCount(focalBlurSampleCount: number): void;

  setFStop(fStop: number): void;

  setApertureBladeCount(apertureBladeCount: number): void;

  setMotionBlurIntensity(motionBlurIntensity: number): void;

  setScreenSpaceAmbientOcclusionIntensity(screenSpaceAmbientOcclusionIntensity: number): void;

  setScreenSpaceAmbientOcclusionRadius(screenSpaceAmbientOcclusionRadius: number): void;

  setScreenSpaceAmbientOcclusionBias(screenSpaceAmbientOcclusionBias: number): void;

  setScreenSpaceAmbientOcclusionDepthThreshold(screenSpaceAmbientOcclusionDepthThreshold: number): void;

  setScreenSpaceAmbientOcclusionNormalThreshold(screenSpaceAmbientOcclusionNormalThreshold: number): void;

  setWantsHDR(wantsHDR: boolean): void;

  setExposureOffset(exposureOffset: number): void;

  setAverageGray(averageGray: number): void;

  setWhitePoint(whitePoint: number): void;

  setWantsExposureAdaptation(wantsExposureAdaptation: boolean): void;

  setExposureAdaptationBrighteningSpeedFactor(exposureAdaptationBrighteningSpeedFactor: number): void;

  setExposureAdaptationDarkeningSpeedFactor(exposureAdaptationDarkeningSpeedFactor: number): void;

  setMinimumExposure(minimumExposure: number): void;

  setMaximumExposure(maximumExposure: number): void;

  setBloomThreshold(bloomThreshold: number): void;

  setBloomIterationCount(bloomIterationCount: number): void;

  setBloomIterationSpread(bloomIterationSpread: number): void;

  setBloomIntensity(bloomIntensity: number): void;

  setBloomBlurRadius(bloomBlurRadius: number): void;

  setVignettingPower(vignettingPower: number): void;

  setVignettingIntensity(vignettingIntensity: number): void;

  setColorFringeStrength(colorFringeStrength: number): void;

  setColorFringeIntensity(colorFringeIntensity: number): void;

  setSaturation(saturation: number): void;

  setContrast(contrast: number): void;

  setGrainIntensity(grainIntensity: number): void;

  setGrainScale(grainScale: number): void;

  setGrainIsColored(grainIsColored: boolean): void;

  setWhiteBalanceTemperature(whiteBalanceTemperature: number): void;

  setWhiteBalanceTint(whiteBalanceTint: number): void;

  setCategoryBitMask(categoryBitMask: number): void;

  focalBlurRadius: number;

  xFov: number;

  yFov: number;

  aperture: number;

  focalSize: number;

  focalDistance: number;

  setFocalBlurRadius(focalBlurRadius: number): void;

  setXFov(xFov: number): void;

  setYFov(yFov: number): void;

  setAperture(aperture: number): void;

  setFocalSize(focalSize: number): void;

  setFocalDistance(focalDistance: number): void;

  static cameraWithMDLCamera<This extends abstract new (...args: any) => any>(this: This, mdlCamera: MDLCamera): InstanceType<This>;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;

  setTechnique(technique: SCNTechnique): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNPyramid extends SCNGeometry {
  static pyramidWithWidthHeightLength<This extends abstract new (...args: any) => any>(this: This, width: number, height: number, length: number): InstanceType<This>;

  width: number;

  height: number;

  length: number;

  widthSegmentCount: number;

  heightSegmentCount: number;

  lengthSegmentCount: number;

  setWidth(width: number): void;

  setHeight(height: number): void;

  setLength(length: number): void;

  setWidthSegmentCount(widthSegmentCount: number): void;

  setHeightSegmentCount(heightSegmentCount: number): void;

  setLengthSegmentCount(lengthSegmentCount: number): void;
}

declare class SCNPhysicsVehicleWheel extends NSObject implements NSCopying, NSSecureCoding {
  static wheelWithNode<This extends abstract new (...args: any) => any>(this: This, node: SCNNode): InstanceType<This>;

  readonly node: SCNNode;

  suspensionStiffness: number;

  suspensionCompression: number;

  suspensionDamping: number;

  maximumSuspensionTravel: number;

  frictionSlip: number;

  maximumSuspensionForce: number;

  connectionPosition: SCNVector3;

  steeringAxis: SCNVector3;

  axle: SCNVector3;

  radius: number;

  suspensionRestLength: number;

  setSuspensionStiffness(suspensionStiffness: number): void;

  setSuspensionCompression(suspensionCompression: number): void;

  setSuspensionDamping(suspensionDamping: number): void;

  setMaximumSuspensionTravel(maximumSuspensionTravel: number): void;

  setFrictionSlip(frictionSlip: number): void;

  setMaximumSuspensionForce(maximumSuspensionForce: number): void;

  setConnectionPosition(connectionPosition: SCNVector3): void;

  setSteeringAxis(steeringAxis: SCNVector3): void;

  setAxle(axle: SCNVector3): void;

  setRadius(radius: number): void;

  setSuspensionRestLength(suspensionRestLength: number): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNProgram extends NSObject implements NSCopying, NSSecureCoding {
  static program<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  vertexShader: string;

  fragmentShader: string;

  tessellationControlShader: string;

  tessellationEvaluationShader: string;

  geometryShader: string;

  vertexFunctionName: string;

  fragmentFunctionName: string;

  handleBindingOfBufferNamedFrequencyUsingBlock(name: string, frequency: interop.Enum<typeof SCNBufferFrequency>, block: (p1: SCNBufferStream, p2: SCNNode, p3: SCNShadable, p4: SCNRenderer) => void): void;

  opaque: boolean;

  setSemanticForSymbolOptions(semantic: string | null, symbol: string, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  semanticForSymbol(symbol: string): string;

  delegate: SCNProgramDelegate;

  library: MTLLibrary;

  setVertexShader(vertexShader: string | null): void;

  setFragmentShader(fragmentShader: string | null): void;

  setTessellationControlShader(tessellationControlShader: string): void;

  setTessellationEvaluationShader(tessellationEvaluationShader: string): void;

  setGeometryShader(geometryShader: string): void;

  setVertexFunctionName(vertexFunctionName: string | null): void;

  setFragmentFunctionName(fragmentFunctionName: string | null): void;

  isOpaque(): boolean;

  setOpaque(opaque: boolean): void;

  setDelegate(delegate: SCNProgramDelegate | null): void;

  setLibrary(library: MTLLibrary | null): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNGeometryTessellator extends NSObject implements NSCopying, NSSecureCoding {
  tessellationFactorScale: number;

  tessellationPartitionMode: interop.Enum<typeof MTLTessellationPartitionMode>;

  adaptive: boolean;

  screenSpace: boolean;

  edgeTessellationFactor: number;

  insideTessellationFactor: number;

  maximumEdgeLength: number;

  smoothingMode: interop.Enum<typeof SCNTessellationSmoothingMode>;

  setTessellationFactorScale(tessellationFactorScale: number): void;

  setTessellationPartitionMode(tessellationPartitionMode: interop.Enum<typeof MTLTessellationPartitionMode>): void;

  isAdaptive(): boolean;

  setAdaptive(adaptive: boolean): void;

  isScreenSpace(): boolean;

  setScreenSpace(screenSpace: boolean): void;

  setEdgeTessellationFactor(edgeTessellationFactor: number): void;

  setInsideTessellationFactor(insideTessellationFactor: number): void;

  setMaximumEdgeLength(maximumEdgeLength: number): void;

  setSmoothingMode(smoothingMode: interop.Enum<typeof SCNTessellationSmoothingMode>): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNSphere extends SCNGeometry {
  static sphereWithRadius<This extends abstract new (...args: any) => any>(this: This, radius: number): InstanceType<This>;

  radius: number;

  geodesic: boolean;

  segmentCount: number;

  setRadius(radius: number): void;

  isGeodesic(): boolean;

  setGeodesic(geodesic: boolean): void;

  setSegmentCount(segmentCount: number): void;
}

declare class SCNCapsule extends SCNGeometry {
  static capsuleWithCapRadiusHeight<This extends abstract new (...args: any) => any>(this: This, capRadius: number, height: number): InstanceType<This>;

  capRadius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;

  capSegmentCount: number;

  setCapRadius(capRadius: number): void;

  setHeight(height: number): void;

  setRadialSegmentCount(radialSegmentCount: number): void;

  setHeightSegmentCount(heightSegmentCount: number): void;

  setCapSegmentCount(capSegmentCount: number): void;
}

declare class SCNSceneSource extends NSObject {
  static sceneSourceWithURLOptions<This extends abstract new (...args: any) => any>(this: This, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static sceneSourceWithDataOptions<This extends abstract new (...args: any) => any>(this: This, data: NSData, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  initWithURLOptions(url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  initWithDataOptions(data: NSData, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  readonly url: NSURL;

  readonly data: NSData;

  sceneWithOptionsStatusHandler(options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, statusHandler: (p1: number, p2: interop.Enum<typeof SCNSceneSourceStatus>, p3: NSError, p4: interop.PointerConvertible) => void | null): SCNScene;

  sceneWithOptionsError(options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): SCNScene;

  propertyForKey(key: string): interop.Object;

  entryWithIdentifierWithClass(uid: string, entryClass: interop.Object): interop.Object;

  identifiersOfEntriesWithClass(entryClass: interop.Object): NSArray;

  entriesPassingTest(predicate: (p1: interop.Object, p2: string, p3: interop.PointerConvertible) => boolean): NSArray;
}

declare class SCNReplicatorConstraint extends SCNConstraint {
  static replicatorConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  target: SCNNode;

  replicatesOrientation: boolean;

  replicatesPosition: boolean;

  replicatesScale: boolean;

  orientationOffset: SCNVector4;

  positionOffset: SCNVector3;

  scaleOffset: SCNVector3;

  setTarget(target: SCNNode | null): void;

  setReplicatesOrientation(replicatesOrientation: boolean): void;

  setReplicatesPosition(replicatesPosition: boolean): void;

  setReplicatesScale(replicatesScale: boolean): void;

  setOrientationOffset(orientationOffset: SCNVector4): void;

  setPositionOffset(positionOffset: SCNVector3): void;

  setScaleOffset(scaleOffset: SCNVector3): void;
}

declare class SCNPhysicsContact extends NSObject {
  readonly nodeA: SCNNode;

  readonly nodeB: SCNNode;

  readonly contactPoint: SCNVector3;

  readonly contactNormal: SCNVector3;

  readonly collisionImpulse: number;

  readonly penetrationDistance: number;

  readonly sweepTestFraction: number;
}

