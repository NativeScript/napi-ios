/// <reference types="@nativescript/objc-node-api" />
/// <reference path="./Runtime.d.ts" />
/// <reference path="./UIKit.d.ts" />

declare const MPMediaItemPropertyAlbumTrackCount: string;

declare const MPMediaItemPropertyAlbumTrackNumber: string;

declare const MPLanguageOptionCharacteristicDescribesMusicAndSound: string;

declare const MPMoviePlayerWillEnterFullscreenNotification: string;

declare const MPMediaItemPropertyHasProtectedAsset: string;

declare const MPMoviePlayerReadyForDisplayDidChangeNotification: string;

declare const MPMediaItemPropertyPodcastPersistentID: string;

declare const MPMoviePlayerLoadStateDidChangeNotification: string;

declare const MPVolumeViewWirelessRouteActiveDidChangeNotification: string;

declare const MPVolumeViewWirelessRoutesAvailableDidChangeNotification: string;

declare const MPLanguageOptionCharacteristicDubbedTranslation: string;

declare const MPLanguageOptionCharacteristicLanguageTranslation: string;

declare const MPLanguageOptionCharacteristicTranscribesSpokenDialog: string;

declare const MPLanguageOptionCharacteristicIsAuxiliaryContent: string;

declare const MPLanguageOptionCharacteristicIsMainProgramContent: string;

declare const MPNowPlayingInfoPropertyAdTimeRanges: string;

declare const MPNowPlayingInfoPropertyCurrentPlaybackDate: string;

declare const MPNowPlayingInfoPropertyExternalContentIdentifier: string;

declare const MPNowPlayingInfoPropertyCurrentLanguageOptions: string;

declare const MPNowPlayingInfoPropertyAvailableLanguageOptions: string;

declare const MPNowPlayingInfoPropertyPlaybackRate: string;

declare const MPMusicPlayerControllerVolumeDidChangeNotification: string;

declare const MPMusicPlayerControllerPlaybackStateDidChangeNotification: string;

declare const MPMoviePlayerTimedMetadataKeyDataType: string;

declare const MPMoviePlayerTimedMetadataUpdatedNotification: string;

declare const MPMoviePlayerThumbnailErrorKey: string;

declare const MPMoviePlayerThumbnailTimeKey: string;

declare const MPMoviePlayerThumbnailImageKey: string;

declare const MPMovieNaturalSizeAvailableNotification: string;

declare const MPMovieMediaTypesAvailableNotification: string;

declare const MPMoviePlayerFullscreenAnimationDurationUserInfoKey: string;

declare const MPMoviePlayerDidEnterFullscreenNotification: string;

declare const MPMoviePlayerNowPlayingMovieDidChangeNotification: string;

declare const MPMoviePlayerPlaybackDidFinishReasonUserInfoKey: string;

declare const MPMoviePlayerScalingModeDidChangeNotification: string;

declare const MPMediaPlaybackIsPreparedToPlayDidChangeNotification: string;

declare const MPMediaPlaylistPropertyPlaylistAttributes: string;

declare const MPMediaPlaylistPropertyPersistentID: string;

declare const MPMediaItemPropertyIsPreorder: string;

declare const MPMediaItemPropertyPlaybackStoreID: string;

declare const MPMediaItemPropertyDateAdded: string;

declare const MPMediaItemPropertyBookmarkTime: string;

declare const MPMediaItemPropertyPlayCount: string;

declare const MPMediaItemPropertyPodcastTitle: string;

declare const MPMediaItemPropertyIsCloudItem: string;

declare const MPMediaItemPropertyLyrics: string;

declare const MPMediaItemPropertyComposerPersistentID: string;

declare const MPMediaItemPropertyComposer: string;

declare const MPMediaItemPropertyAlbumArtistPersistentID: string;

declare const MPMediaItemPropertyAlbumTitle: string;

declare const MPMediaItemPropertyMediaType: string;

declare const MPMediaEntityPropertyPersistentID: string;

declare const MPNowPlayingInfoPropertyInternationalStandardRecordingCode: string;

declare const MPMediaItemPropertyDiscCount: string;

declare const MPNowPlayingInfoPropertyMediaType: string;

declare const MPMoviePlayerWillExitFullscreenNotification: string;

declare const MPLanguageOptionCharacteristicEasyToRead: string;

declare const MPNowPlayingInfoCollectionIdentifier: string;

declare const MPMediaPlaylistPropertyName: string;

declare const MPNowPlayingInfoPropertyIsLiveStream: string;

declare const MPMoviePlayerTimedMetadataUserInfoKey: string;

declare const MPMoviePlayerPlaybackDidFinishNotification: string;

declare const MPMoviePlayerTimedMetadataKeyInfo: string;

declare const MPMediaItemPropertyAlbumPersistentID: string;

declare const MPMediaPlaylistPropertyDescriptionText: string;

declare const MPMediaItemPropertyPersistentID: string;

declare const MPMediaPlaylistPropertyCloudGlobalID: string;

declare const MPMediaItemPropertySkipCount: string;

declare const MPMoviePlayerDidExitFullscreenNotification: string;

declare const MPMediaItemPropertyLastPlayedDate: string;

declare const MPMediaItemPropertyRating: string;

declare const MPMoviePlayerIsAirPlayVideoActiveDidChangeNotification: string;

declare const MPNowPlayingInfoPropertyCreditsStartTime: string;

declare const MPMovieSourceTypeAvailableNotification: string;

declare const MPMediaItemPropertyAssetURL: string;

declare const MPMediaPlaylistPropertyAuthorDisplayName: string;

declare const MPMediaItemPropertyGenre: string;

declare const MPNowPlayingInfoPropertyChapterNumber: string;

declare const MPMusicPlayerControllerNowPlayingItemDidChangeNotification: string;

declare const MPNowPlayingInfoPropertyPlaybackQueueCount: string;

declare const MPMediaItemPropertyArtistPersistentID: string;

declare const MPMediaItemPropertyIsExplicit: string;

declare const MPLanguageOptionCharacteristicDescribesVideo: string;

declare const MPNowPlayingInfoPropertyServiceIdentifier: string;

declare const MPNowPlayingInfoPropertyPlaybackProgress: string;

declare const MPLanguageOptionCharacteristicContainsOnlyForcedSubtitles: string;

declare const MPLanguageOptionCharacteristicVoiceOverTranslation: string;

declare const MPMoviePlayerTimedMetadataKeyLanguageCode: string;

declare const MPNowPlayingInfoPropertyPlaybackQueueIndex: string;

declare const MPMediaItemPropertyDiscNumber: string;

declare const MPMediaItemPropertyComments: string;

declare const MPMediaItemPropertyAlbumArtist: string;

declare const MPNowPlayingInfoPropertyDefaultPlaybackRate: string;

declare const MPNowPlayingInfoProperty3x4AnimatedArtwork: string;

declare const MPNowPlayingInfoPropertyAssetURL: string;

declare const MPMusicPlayerControllerQueueDidChangeNotification: string;

declare const MPMediaItemPropertyArtist: string;

declare const MPMediaItemPropertyPlaybackDuration: string;

declare const MPMovieDurationAvailableNotification: string;

declare const MPNowPlayingInfoProperty1x1AnimatedArtwork: string;

declare const MPMediaItemPropertyArtwork: string;

declare const MPNowPlayingInfoPropertyChapterCount: string;

declare const MPMediaItemPropertyGenrePersistentID: string;

declare const MPNowPlayingInfoPropertyExcludeFromSuggestions: string;

declare const MPNowPlayingInfoPropertyElapsedPlaybackTime: string;

declare const MPMoviePlayerFullscreenAnimationCurveUserInfoKey: string;

declare const MPErrorDomain: string;

declare const MPMediaItemPropertyReleaseDate: string;

declare const MPMoviePlayerTimedMetadataKeyMIMEType: string;

declare const MPMediaLibraryDidChangeNotification: string;

declare const MPMoviePlayerTimedMetadataKeyName: string;

declare const MPMoviePlayerPlaybackStateDidChangeNotification: string;

declare const MPMediaItemPropertyIsCompilation: string;

declare const MPNowPlayingInfoPropertyExternalUserProfileIdentifier: string;

declare const MPMediaItemPropertyTitle: string;

declare const MPMoviePlayerThumbnailImageRequestDidFinishNotification: string;

declare const MPMediaPlaylistPropertySeedItems: string;

declare const MPMediaItemPropertyBeatsPerMinute: string;

declare const MPMediaItemPropertyUserGrouping: string;

declare const MPSeekCommandEventType: {
  Begin: 0,
  End: 1,
};

declare const MPChangeLanguageOptionSetting: {
  None: 0,
  NowPlayingItemOnly: 1,
  Permanent: 2,
};

declare const MPRepeatType: {
  Off: 0,
  One: 1,
  All: 2,
};

declare const MPShuffleType: {
  Off: 0,
  Items: 1,
  Collections: 2,
};

declare const MPMusicShuffleMode: {
  Default: 0,
  Off: 1,
  Songs: 2,
  Albums: 3,
};

declare const MPMusicRepeatMode: {
  Default: 0,
  None: 1,
  One: 2,
  All: 3,
};

declare const MPMovieTimeOption: {
  NearestKeyFrame: 0,
  Exact: 1,
};

declare const MPMovieRepeatMode: {
  None: 0,
  One: 1,
};

declare const MPMovieLoadState: {
  Unknown: 0,
  Playable: 1,
  PlaythroughOK: 2,
  Stalled: 4,
};

declare const MPMovieScalingMode: {
  None: 0,
  AspectFit: 1,
  AspectFill: 2,
  Fill: 3,
};

declare const MPMediaPlaylistAttribute: {
  None: 0,
  OnTheGo: 1,
  Smart: 2,
  Genius: 4,
};

declare const MPMediaLibraryAuthorizationStatus: {
  NotDetermined: 0,
  Denied: 1,
  Restricted: 2,
  Authorized: 3,
};

declare const MPMovieControlStyle: {
  None: 0,
  Embedded: 1,
  Fullscreen: 2,
  Default: 1,
};

declare const MPMovieSourceType: {
  Unknown: 0,
  File: 1,
  Streaming: 2,
};

declare const MPNowPlayingPlaybackState: {
  Unknown: 0,
  Playing: 1,
  Paused: 2,
  Stopped: 3,
  Interrupted: 4,
};

declare const MPMovieMediaTypeMask: {
  None: 0,
  Video: 1,
  Audio: 2,
};

declare const MPNowPlayingInfoLanguageOptionType: {
  Audible: 0,
  Legible: 1,
};

declare const MPMediaType: {
  Music: 1,
  Podcast: 2,
  AudioBook: 4,
  AudioITunesU: 8,
  AnyAudio: 255,
  Movie: 256,
  TVShow: 512,
  VideoPodcast: 1024,
  MusicVideo: 2048,
  VideoITunesU: 4096,
  HomeVideo: 8192,
  AnyVideo: 65280,
  Any: -1,
};

declare const MPNowPlayingInfoMediaType: {
  None: 0,
  Audio: 1,
  Video: 2,
};

declare const MPRemoteCommandHandlerStatus: {
  Success: 0,
  NoSuchContent: 100,
  NoActionableNowPlayingItem: 110,
  DeviceNotFound: 120,
  CommandFailed: 200,
};

declare const MPMusicPlaybackState: {
  Stopped: 0,
  Playing: 1,
  Paused: 2,
  Interrupted: 3,
  SeekingForward: 4,
  SeekingBackward: 5,
};

declare const MPMediaGrouping: {
  Title: 0,
  Album: 1,
  Artist: 2,
  AlbumArtist: 3,
  Composer: 4,
  Genre: 5,
  Playlist: 6,
  PodcastTitle: 7,
};

declare const MPMediaPredicateComparison: {
  EqualTo: 0,
  Contains: 1,
};

declare const MPMovieFinishReason: {
  PlaybackEnded: 0,
  PlaybackError: 1,
  UserExited: 2,
};

declare const MPErrorCode: {
  Unknown: 0,
  PermissionDenied: 1,
  CloudServiceCapabilityMissing: 2,
  NetworkConnectionFailed: 3,
  NotFound: 4,
  NotSupported: 5,
  Cancelled: 6,
  RequestTimedOut: 7,
};

declare const MPMoviePlaybackState: {
  Stopped: 0,
  Playing: 1,
  Paused: 2,
  Interrupted: 3,
  SeekingForward: 4,
  SeekingBackward: 5,
};

declare function MPVolumeSettingsAlertShow(): void;

declare function MPVolumeSettingsAlertHide(): void;

declare function MPVolumeSettingsAlertIsVisible(): boolean;

declare interface MPNowPlayingSessionDelegate extends NSObjectProtocol {
  nowPlayingSessionDidChangeActive?(nowPlayingSession: MPNowPlayingSession): void;

  nowPlayingSessionDidChangeCanBecomeActive?(nowPlayingSession: MPNowPlayingSession): void;
}

declare class MPNowPlayingSessionDelegate extends NativeObject implements MPNowPlayingSessionDelegate {
}

declare interface MPSystemMusicPlayerController extends NSObjectProtocol {
  openToPlayQueueDescriptor(queueDescriptor: MPMusicPlayerQueueDescriptor): void;
}

declare class MPSystemMusicPlayerController extends NativeObject implements MPSystemMusicPlayerController {
}

declare interface MPPlayableContentDataSource extends NSObjectProtocol {
  beginLoadingChildItemsAtIndexPathCompletionHandler?(indexPath: NSIndexPath, completionHandler: (p1: NSError) => void | null): void;

  childItemsDisplayPlaybackProgressAtIndexPath?(indexPath: NSIndexPath): boolean;

  contentItemForIdentifierCompletionHandler?(identifier: string, completionHandler: (p1: MPContentItem, p2: NSError) => void | null): void;

  numberOfChildItemsAtIndexPath(indexPath: NSIndexPath): number;

  contentItemAtIndexPath(indexPath: NSIndexPath): MPContentItem;
}

declare class MPPlayableContentDataSource extends NativeObject implements MPPlayableContentDataSource {
}

declare interface MPPlayableContentDelegate extends NSObjectProtocol {
  playableContentManagerInitiatePlaybackOfContentItemAtIndexPathCompletionHandler?(contentManager: MPPlayableContentManager, indexPath: NSIndexPath, completionHandler: (p1: NSError) => void | null): void;

  playableContentManagerInitializePlaybackQueueWithCompletionHandler?(contentManager: MPPlayableContentManager, completionHandler: (p1: NSError) => void | null): void;

  playableContentManagerInitializePlaybackQueueWithContentItemsCompletionHandler?(contentManager: MPPlayableContentManager, contentItems: NSArray<interop.Object> | Array<interop.Object> | null, completionHandler: (p1: NSError) => void | null): void;

  playableContentManagerDidUpdateContext?(contentManager: MPPlayableContentManager, context: MPPlayableContentManagerContext): void;
}

declare class MPPlayableContentDelegate extends NativeObject implements MPPlayableContentDelegate {
}

declare interface MPMediaPickerControllerDelegate extends NSObjectProtocol {
  mediaPickerDidPickMediaItems?(mediaPicker: MPMediaPickerController, mediaItemCollection: MPMediaItemCollection): void;

  mediaPickerDidCancel?(mediaPicker: MPMediaPickerController): void;
}

declare class MPMediaPickerControllerDelegate extends NativeObject implements MPMediaPickerControllerDelegate {
}

declare interface MPMediaPlayback {
  prepareToPlay(): void;

  readonly isPreparedToPlay: boolean;

  play(): void;

  pause(): void;

  stop(): void;

  currentPlaybackTime: number;

  currentPlaybackRate: number;

  beginSeekingForward(): void;

  beginSeekingBackward(): void;

  endSeeking(): void;

  setCurrentPlaybackTime(currentPlaybackTime: number): void;

  setCurrentPlaybackRate(currentPlaybackRate: number): void;
}

declare class MPMediaPlayback extends NativeObject implements MPMediaPlayback {
}

declare class MPSeekCommandEvent extends MPRemoteCommandEvent {
  readonly type: interop.Enum<typeof MPSeekCommandEventType>;
}

declare class MPMediaQuery extends NSObject implements NSSecureCoding, NSCopying {
  initWithFilterPredicates(filterPredicates: NSSet | null): this;

  filterPredicates: NSSet;

  addFilterPredicate(predicate: MPMediaPredicate): void;

  removeFilterPredicate(predicate: MPMediaPredicate): void;

  readonly items: NSArray;

  readonly collections: NSArray;

  groupingType: interop.Enum<typeof MPMediaGrouping>;

  readonly itemSections: NSArray;

  readonly collectionSections: NSArray;

  static albumsQuery(): MPMediaQuery;

  static artistsQuery(): MPMediaQuery;

  static songsQuery(): MPMediaQuery;

  static playlistsQuery(): MPMediaQuery;

  static podcastsQuery(): MPMediaQuery;

  static audiobooksQuery(): MPMediaQuery;

  static compilationsQuery(): MPMediaQuery;

  static composersQuery(): MPMediaQuery;

  static genresQuery(): MPMediaQuery;

  setFilterPredicates(filterPredicates: NSSet | null): void;

  setGroupingType(groupingType: interop.Enum<typeof MPMediaGrouping>): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class MPChangeRepeatModeCommandEvent extends MPRemoteCommandEvent {
  readonly repeatType: interop.Enum<typeof MPRepeatType>;

  readonly preservesRepeatMode: boolean;
}

declare class MPChangeShuffleModeCommandEvent extends MPRemoteCommandEvent {
  readonly shuffleType: interop.Enum<typeof MPShuffleType>;

  readonly preservesShuffleMode: boolean;
}

declare class MPChangePlaybackPositionCommandEvent extends MPRemoteCommandEvent {
  readonly positionTime: number;
}

declare class MPChangeLanguageOptionCommandEvent extends MPRemoteCommandEvent {
  readonly languageOption: MPNowPlayingInfoLanguageOption;

  readonly setting: interop.Enum<typeof MPChangeLanguageOptionSetting>;
}

declare class MPChangePlaybackRateCommandEvent extends MPRemoteCommandEvent {
  readonly playbackRate: number;
}

declare class MPSkipIntervalCommandEvent extends MPRemoteCommandEvent {
  readonly interval: number;
}

declare class MPRemoteCommandEvent extends NSObject {
  readonly command: MPRemoteCommand;

  readonly timestamp: number;
}

declare class MPRemoteCommandCenter extends NSObject {
  readonly pauseCommand: MPRemoteCommand;

  readonly playCommand: MPRemoteCommand;

  readonly stopCommand: MPRemoteCommand;

  readonly togglePlayPauseCommand: MPRemoteCommand;

  readonly enableLanguageOptionCommand: MPRemoteCommand;

  readonly disableLanguageOptionCommand: MPRemoteCommand;

  readonly changePlaybackRateCommand: MPChangePlaybackRateCommand;

  readonly changeRepeatModeCommand: MPChangeRepeatModeCommand;

  readonly changeShuffleModeCommand: MPChangeShuffleModeCommand;

  readonly nextTrackCommand: MPRemoteCommand;

  readonly previousTrackCommand: MPRemoteCommand;

  readonly skipForwardCommand: MPSkipIntervalCommand;

  readonly skipBackwardCommand: MPSkipIntervalCommand;

  readonly seekForwardCommand: MPRemoteCommand;

  readonly seekBackwardCommand: MPRemoteCommand;

  readonly changePlaybackPositionCommand: MPChangePlaybackPositionCommand;

  readonly ratingCommand: MPRatingCommand;

  readonly likeCommand: MPFeedbackCommand;

  readonly dislikeCommand: MPFeedbackCommand;

  readonly bookmarkCommand: MPFeedbackCommand;

  static sharedCommandCenter(): MPRemoteCommandCenter;
}

declare class MPChangeRepeatModeCommand extends MPRemoteCommand {
  currentRepeatType: interop.Enum<typeof MPRepeatType>;

  setCurrentRepeatType(currentRepeatType: interop.Enum<typeof MPRepeatType>): void;
}

declare class MPChangePlaybackPositionCommand extends MPRemoteCommand {
}

declare class MPChangePlaybackRateCommand extends MPRemoteCommand {
  get supportedPlaybackRates(): NSArray;
  set supportedPlaybackRates(value: NSArray<interop.Object> | Array<interop.Object>);

  setSupportedPlaybackRates(supportedPlaybackRates: NSArray<interop.Object> | Array<interop.Object>): void;
}

declare class MPRatingCommand extends MPRemoteCommand {
  minimumRating: number;

  maximumRating: number;

  setMinimumRating(minimumRating: number): void;

  setMaximumRating(maximumRating: number): void;
}

declare class MPRemoteCommand extends NSObject {
  enabled: boolean;

  addTargetAction(target: interop.Object, action: string): void;

  removeTargetAction(target: interop.Object, action: string | null): void;

  removeTarget(target: interop.Object | null): void;

  addTargetWithHandler(handler: (p1: MPRemoteCommandEvent) => interop.Enum<typeof MPRemoteCommandHandlerStatus>): interop.Object;

  isEnabled(): boolean;

  setEnabled(enabled: boolean): void;
}

declare class MPPlayableContentManagerContext extends NSObject {
  readonly enforcedContentItemsCount: number;

  readonly enforcedContentTreeDepth: number;

  readonly contentLimitsEnforced: boolean;

  readonly contentLimitsEnabled: boolean;

  readonly endpointAvailable: boolean;
}

declare class MPNowPlayingSession extends NSObject {
  initWithPlayers(players: NSArray<interop.Object> | Array<interop.Object>): this;

  readonly players: NSArray;

  delegate: MPNowPlayingSessionDelegate;

  automaticallyPublishesNowPlayingInfo: boolean;

  readonly nowPlayingInfoCenter: MPNowPlayingInfoCenter;

  readonly remoteCommandCenter: MPRemoteCommandCenter;

  readonly canBecomeActive: boolean;

  readonly active: boolean;

  becomeActiveIfPossibleWithCompletion(completion: (p1: boolean) => void | null): void;

  addPlayer(player: AVPlayer): void;

  removePlayer(player: AVPlayer): void;

  setDelegate(delegate: MPNowPlayingSessionDelegate | null): void;

  setAutomaticallyPublishesNowPlayingInfo(automaticallyPublishesNowPlayingInfo: boolean): void;

  isActive(): boolean;
}

declare class MPNowPlayingInfoLanguageOption extends NSObject {
  initWithTypeLanguageTagCharacteristicsDisplayNameIdentifier(languageOptionType: interop.Enum<typeof MPNowPlayingInfoLanguageOptionType>, languageTag: string, languageOptionCharacteristics: NSArray<interop.Object> | Array<interop.Object> | null, displayName: string, identifier: string): this;

  isAutomaticLegibleLanguageOption(): boolean;

  isAutomaticAudibleLanguageOption(): boolean;

  readonly languageOptionType: interop.Enum<typeof MPNowPlayingInfoLanguageOptionType>;

  readonly languageTag: string;

  readonly languageOptionCharacteristics: NSArray;

  readonly displayName: string;

  readonly identifier: string;
}

declare class MPNowPlayingInfoCenter extends NSObject {
  static defaultCenter(): MPNowPlayingInfoCenter;

  get nowPlayingInfo(): NSDictionary;
  set nowPlayingInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  playbackState: interop.Enum<typeof MPNowPlayingPlaybackState>;

  static readonly supportedAnimatedArtworkKeys: NSArray;

  setNowPlayingInfo(nowPlayingInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  setPlaybackState(playbackState: interop.Enum<typeof MPNowPlayingPlaybackState>): void;
}

declare class MPMusicPlayerPlayParametersQueueDescriptor extends MPMusicPlayerQueueDescriptor {
  initWithPlayParametersQueue(playParametersQueue: NSArray<interop.Object> | Array<interop.Object>): this;

  get playParametersQueue(): NSArray;
  set playParametersQueue(value: NSArray<interop.Object> | Array<interop.Object>);

  startItemPlayParameters: MPMusicPlayerPlayParameters;

  setStartTimeForItemWithPlayParameters(startTime: number, playParameters: MPMusicPlayerPlayParameters): void;

  setEndTimeForItemWithPlayParameters(endTime: number, playParameters: MPMusicPlayerPlayParameters): void;

  setPlayParametersQueue(playParametersQueue: NSArray<interop.Object> | Array<interop.Object>): void;

  setStartItemPlayParameters(startItemPlayParameters: MPMusicPlayerPlayParameters | null): void;
}

declare class MPMusicPlayerStoreQueueDescriptor extends MPMusicPlayerQueueDescriptor {
  initWithStoreIDs(storeIDs: NSArray<interop.Object> | Array<interop.Object>): this;

  get storeIDs(): NSArray;
  set storeIDs(value: NSArray<interop.Object> | Array<interop.Object>);

  startItemID: string;

  setStartTimeForItemWithStoreID(startTime: number, storeID: string): void;

  setEndTimeForItemWithStoreID(endTime: number, storeID: string): void;

  setStoreIDs(storeIDs: NSArray<interop.Object> | Array<interop.Object> | null): void;

  setStartItemID(startItemID: string | null): void;
}

declare class MPMusicPlayerQueueDescriptor extends NSObject {
}

declare class MPMovieErrorLogEvent extends NSObject implements NSCopying {
  readonly date: NSDate;

  readonly URI: string;

  readonly serverAddress: string;

  readonly playbackSessionID: string;

  readonly errorStatusCode: number;

  readonly errorDomain: string;

  readonly errorComment: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class MPMovieAccessLogEvent extends NSObject implements NSCopying {
  readonly numberOfSegmentsDownloaded: number;

  readonly playbackStartDate: NSDate;

  readonly URI: string;

  readonly serverAddress: string;

  readonly numberOfServerAddressChanges: number;

  readonly playbackSessionID: string;

  readonly playbackStartOffset: number;

  readonly segmentsDownloadedDuration: number;

  readonly durationWatched: number;

  readonly numberOfStalls: number;

  readonly numberOfBytesTransferred: number;

  readonly observedBitrate: number;

  readonly indicatedBitrate: number;

  readonly numberOfDroppedVideoFrames: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class MPMoviePlayerController extends NSObject implements MPMediaPlayback {
  initWithContentURL(url: NSURL): this;

  contentURL: NSURL;

  readonly view: UIView;

  readonly backgroundView: UIView;

  readonly playbackState: interop.Enum<typeof MPMoviePlaybackState>;

  readonly loadState: interop.Enum<typeof MPMovieLoadState>;

  controlStyle: interop.Enum<typeof MPMovieControlStyle>;

  repeatMode: interop.Enum<typeof MPMovieRepeatMode>;

  shouldAutoplay: boolean;

  fullscreen: boolean;

  setFullscreenAnimated(fullscreen: boolean, animated: boolean): void;

  scalingMode: interop.Enum<typeof MPMovieScalingMode>;

  readonly readyForDisplay: boolean;

  readonly movieMediaTypes: interop.Enum<typeof MPMovieMediaTypeMask>;

  movieSourceType: interop.Enum<typeof MPMovieSourceType>;

  readonly duration: number;

  readonly playableDuration: number;

  readonly naturalSize: CGSize;

  initialPlaybackTime: number;

  endPlaybackTime: number;

  allowsAirPlay: boolean;

  readonly airPlayVideoActive: boolean;

  setContentURL(contentURL: NSURL): void;

  setControlStyle(controlStyle: interop.Enum<typeof MPMovieControlStyle>): void;

  setRepeatMode(repeatMode: interop.Enum<typeof MPMovieRepeatMode>): void;

  setShouldAutoplay(shouldAutoplay: boolean): void;

  isFullscreen(): boolean;

  setFullscreen(fullscreen: boolean): void;

  setScalingMode(scalingMode: interop.Enum<typeof MPMovieScalingMode>): void;

  setMovieSourceType(movieSourceType: interop.Enum<typeof MPMovieSourceType>): void;

  setInitialPlaybackTime(initialPlaybackTime: number): void;

  setEndPlaybackTime(endPlaybackTime: number): void;

  setAllowsAirPlay(allowsAirPlay: boolean): void;

  isAirPlayVideoActive(): boolean;

  thumbnailImageAtTimeTimeOption(playbackTime: number, option: interop.Enum<typeof MPMovieTimeOption>): UIImage;

  requestThumbnailImagesAtTimesTimeOption(playbackTimes: NSArray<interop.Object> | Array<interop.Object>, option: interop.Enum<typeof MPMovieTimeOption>): void;

  cancelAllThumbnailImageRequests(): void;

  readonly timedMetadata: NSArray;

  readonly accessLog: MPMovieAccessLog;

  readonly errorLog: MPMovieErrorLog;

  useApplicationAudioSession: boolean;

  setUseApplicationAudioSession(useApplicationAudioSession: boolean): void;

  prepareToPlay(): void;

  readonly isPreparedToPlay: boolean;

  play(): void;

  pause(): void;

  stop(): void;

  currentPlaybackTime: number;

  currentPlaybackRate: number;

  beginSeekingForward(): void;

  beginSeekingBackward(): void;

  endSeeking(): void;

  setCurrentPlaybackTime(currentPlaybackTime: number): void;

  setCurrentPlaybackRate(currentPlaybackRate: number): void;
}

declare class MPMediaPlaylistCreationMetadata extends NSObject {
  initWithName(name: string): this;

  readonly name: string;

  authorDisplayName: string;

  descriptionText: string;

  setAuthorDisplayName(authorDisplayName: string | null): void;

  setDescriptionText(descriptionText: string): void;
}

declare class MPMediaItemCollection extends MPMediaEntity {
  static collectionWithItems(items: NSArray<interop.Object> | Array<interop.Object>): MPMediaItemCollection;

  initWithItems(items: NSArray<interop.Object> | Array<interop.Object>): this;

  readonly items: NSArray;

  readonly representativeItem: MPMediaItem;

  readonly count: number;

  readonly mediaTypes: interop.Enum<typeof MPMediaType>;
}

declare class MPMediaItemAnimatedArtwork extends NSObject {
  initWithArtworkIDPreviewImageRequestHandlerVideoAssetFileURLRequestHandler(artworkID: string, previewImageRequestHandler: (p1: CGSize, p2: (p1: UIImage) => void) => void | null, videoAssetFileURLRequestHandler: (p1: CGSize, p2: (p1: NSURL) => void) => void | null): this;
}

declare class MPMediaItemArtwork extends NSObject {
  initWithBoundsSizeRequestHandler(boundsSize: CGSize, requestHandler: (p1: CGSize) => UIImage): this;

  imageWithSize(size: CGSize): UIImage;

  readonly bounds: CGRect;

  readonly imageCropRect: CGRect;

  initWithImage(image: UIImage): this;
}

declare class MPMediaEntity extends NSObject implements NSSecureCoding {
  static canFilterByProperty(property: string): boolean;

  enumerateValuesForPropertiesUsingBlock(properties: NSSet, block: (p1: string, p2: interop.Object, p3: interop.PointerConvertible) => void): void;

  objectForKeyedSubscript(key: interop.Object): interop.Object;

  valueForProperty(property: string): interop.Object;

  readonly persistentID: number;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class MPContentItem extends NSObject {
  initWithIdentifier(identifier: string): this;

  readonly identifier: string;

  title: string;

  subtitle: string;

  artwork: MPMediaItemArtwork;

  playbackProgress: number;

  streamingContent: boolean;

  explicitContent: boolean;

  container: boolean;

  playable: boolean;

  setTitle(title: string | null): void;

  setSubtitle(subtitle: string | null): void;

  setArtwork(artwork: MPMediaItemArtwork | null): void;

  setPlaybackProgress(playbackProgress: number): void;

  isStreamingContent(): boolean;

  setStreamingContent(streamingContent: boolean): void;

  isExplicitContent(): boolean;

  setExplicitContent(explicitContent: boolean): void;

  isContainer(): boolean;

  setContainer(container: boolean): void;

  isPlayable(): boolean;

  setPlayable(playable: boolean): void;
}

declare class MPMediaQuerySection extends NSObject implements NSSecureCoding, NSCopying {
  readonly title: string;

  readonly range: _NSRange;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class MPChangeShuffleModeCommand extends MPRemoteCommand {
  currentShuffleType: interop.Enum<typeof MPShuffleType>;

  setCurrentShuffleType(currentShuffleType: interop.Enum<typeof MPShuffleType>): void;
}

declare class MPMusicPlayerControllerQueue extends NSObject {
  readonly items: NSArray;
}

declare class MPRatingCommandEvent extends MPRemoteCommandEvent {
  readonly rating: number;
}

declare class MPSkipIntervalCommand extends MPRemoteCommand {
  get preferredIntervals(): NSArray;
  set preferredIntervals(value: NSArray<interop.Object> | Array<interop.Object>);

  setPreferredIntervals(preferredIntervals: NSArray<interop.Object> | Array<interop.Object>): void;
}

declare class MPPlayableContentManager extends NSObject {
  dataSource: MPPlayableContentDataSource;

  delegate: MPPlayableContentDelegate;

  readonly context: MPPlayableContentManagerContext;

  get nowPlayingIdentifiers(): NSArray;
  set nowPlayingIdentifiers(value: NSArray<interop.Object> | Array<interop.Object>);

  static sharedContentManager<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  reloadData(): void;

  beginUpdates(): void;

  endUpdates(): void;

  setDataSource(dataSource: MPPlayableContentDataSource | null): void;

  setDelegate(delegate: MPPlayableContentDelegate | null): void;

  setNowPlayingIdentifiers(nowPlayingIdentifiers: NSArray<interop.Object> | Array<interop.Object>): void;
}

declare class MPTimedMetadata extends NSObject {
  readonly key: string;

  readonly keyspace: string;

  readonly value: interop.Object;

  readonly timestamp: number;

  readonly allMetadata: NSDictionary;
}

declare class MPMusicPlayerApplicationController extends MPMusicPlayerController {
  performQueueTransactionCompletionHandler(queueTransaction: (p1: MPMusicPlayerControllerMutableQueue) => void, completionHandler: (p1: MPMusicPlayerControllerQueue, p2: NSError) => void | null): void;
}

declare class MPMediaPlaylist extends MPMediaItemCollection {
  readonly persistentID: number;

  readonly cloudGlobalID: string;

  readonly name: string;

  readonly playlistAttributes: interop.Enum<typeof MPMediaPlaylistAttribute>;

  readonly seedItems: NSArray;

  readonly descriptionText: string;

  readonly authorDisplayName: string;

  addItemWithProductIDCompletionHandler(productID: string, completionHandler: (p1: NSError) => void | null): void;

  addMediaItemsCompletionHandler(mediaItems: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: NSError) => void | null): void;
}

declare class MPMediaPickerController extends UIViewController {
  initWithMediaTypes(mediaTypes: interop.Enum<typeof MPMediaType>): this;

  readonly mediaTypes: interop.Enum<typeof MPMediaType>;

  delegate: MPMediaPickerControllerDelegate;

  allowsPickingMultipleItems: boolean;

  showsCloudItems: boolean;

  showsItemsWithProtectedAssets: boolean;

  prompt: string;

  setDelegate(delegate: MPMediaPickerControllerDelegate | null): void;

  setAllowsPickingMultipleItems(allowsPickingMultipleItems: boolean): void;

  setShowsCloudItems(showsCloudItems: boolean): void;

  setShowsItemsWithProtectedAssets(showsItemsWithProtectedAssets: boolean): void;

  setPrompt(prompt: string | null): void;
}

declare class MPMusicPlayerController extends NSObject implements MPMediaPlayback {
  static readonly applicationMusicPlayer: MPMusicPlayerController;

  static readonly applicationQueuePlayer: MPMusicPlayerApplicationController;

  static readonly systemMusicPlayer: MPMusicPlayerController;

  readonly playbackState: interop.Enum<typeof MPMusicPlaybackState>;

  repeatMode: interop.Enum<typeof MPMusicRepeatMode>;

  shuffleMode: interop.Enum<typeof MPMusicShuffleMode>;

  volume: number;

  nowPlayingItem: MPMediaItem;

  readonly indexOfNowPlayingItem: number;

  setQueueWithQuery(query: MPMediaQuery): void;

  setQueueWithItemCollection(itemCollection: MPMediaItemCollection): void;

  setQueueWithStoreIDs(storeIDs: NSArray<interop.Object> | Array<interop.Object>): void;

  setQueueWithDescriptor(descriptor: MPMusicPlayerQueueDescriptor): void;

  prependQueueDescriptor(descriptor: MPMusicPlayerQueueDescriptor): void;

  appendQueueDescriptor(descriptor: MPMusicPlayerQueueDescriptor): void;

  prepareToPlayWithCompletionHandler(completionHandler: (p1: NSError) => void | null): void;

  skipToNextItem(): void;

  skipToBeginning(): void;

  skipToPreviousItem(): void;

  beginGeneratingPlaybackNotifications(): void;

  endGeneratingPlaybackNotifications(): void;

  static readonly iPodMusicPlayer: MPMusicPlayerController;

  setRepeatMode(repeatMode: interop.Enum<typeof MPMusicRepeatMode>): void;

  setShuffleMode(shuffleMode: interop.Enum<typeof MPMusicShuffleMode>): void;

  setVolume(volume: number): void;

  setNowPlayingItem(nowPlayingItem: MPMediaItem | null): void;

  prepareToPlay(): void;

  readonly isPreparedToPlay: boolean;

  play(): void;

  pause(): void;

  stop(): void;

  currentPlaybackTime: number;

  currentPlaybackRate: number;

  beginSeekingForward(): void;

  beginSeekingBackward(): void;

  endSeeking(): void;

  setCurrentPlaybackTime(currentPlaybackTime: number): void;

  setCurrentPlaybackRate(currentPlaybackRate: number): void;
}

declare class MPMovieAccessLog extends NSObject implements NSCopying {
  readonly extendedLogData: NSData;

  readonly extendedLogDataStringEncoding: number;

  readonly events: NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class MPMoviePlayerViewController extends UIViewController {
  initWithContentURL(contentURL: NSURL): this;

  readonly moviePlayer: MPMoviePlayerController;
}

declare class MPFeedbackCommand extends MPRemoteCommand {
  active: boolean;

  localizedTitle: string;

  localizedShortTitle: string;

  isActive(): boolean;

  setActive(active: boolean): void;

  setLocalizedTitle(localizedTitle: string): void;

  setLocalizedShortTitle(localizedShortTitle: string): void;
}

declare class MPMovieErrorLog extends NSObject implements NSCopying {
  readonly extendedLogData: NSData;

  readonly extendedLogDataStringEncoding: number;

  readonly events: NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class MPMusicPlayerPlayParameters extends NSObject {
  initWithDictionary(dictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  readonly dictionary: NSDictionary;
}

declare class MPMediaPredicate extends NSObject implements NSSecureCoding {
  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class MPMusicPlayerMediaItemQueueDescriptor extends MPMusicPlayerQueueDescriptor {
  initWithQuery(query: MPMediaQuery): this;

  initWithItemCollection(itemCollection: MPMediaItemCollection): this;

  readonly query: MPMediaQuery;

  readonly itemCollection: MPMediaItemCollection;

  startItem: MPMediaItem;

  setStartTimeForItem(startTime: number, mediaItem: MPMediaItem): void;

  setEndTimeForItem(endTime: number, mediaItem: MPMediaItem): void;

  setStartItem(startItem: MPMediaItem | null): void;
}

declare class MPMediaLibrary extends NSObject implements NSSecureCoding {
  static defaultMediaLibrary(): MPMediaLibrary;

  readonly lastModifiedDate: NSDate;

  beginGeneratingLibraryChangeNotifications(): void;

  endGeneratingLibraryChangeNotifications(): void;

  static authorizationStatus(): interop.Enum<typeof MPMediaLibraryAuthorizationStatus>;

  static requestAuthorization(completionHandler: (p1: interop.Enum<typeof MPMediaLibraryAuthorizationStatus>) => void): void;

  addItemWithProductIDCompletionHandler(productID: string, completionHandler: (p1: NSArray<interop.Object> | Array<interop.Object>, p2: NSError) => void | null): void;

  getPlaylistWithUUIDCreationMetadataCompletionHandler(uuid: NSUUID, creationMetadata: MPMediaPlaylistCreationMetadata | null, completionHandler: (p1: MPMediaPlaylist, p2: NSError) => void | null): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class MPMediaPropertyPredicate extends MPMediaPredicate {
  static predicateWithValueForProperty(value: interop.Object | null, property: string): MPMediaPropertyPredicate;

  static predicateWithValueForPropertyComparisonType(value: interop.Object | null, property: string, comparisonType: interop.Enum<typeof MPMediaPredicateComparison>): MPMediaPropertyPredicate;

  readonly property: string;

  readonly value: interop.Object;

  readonly comparisonType: interop.Enum<typeof MPMediaPredicateComparison>;
}

declare class MPMusicPlayerControllerMutableQueue extends MPMusicPlayerControllerQueue {
  insertQueueDescriptorAfterItem(queueDescriptor: MPMusicPlayerQueueDescriptor, afterItem: MPMediaItem | null): void;

  removeItem(item: MPMediaItem): void;
}

declare class MPMediaItem extends MPMediaEntity {
  readonly persistentID: number;

  readonly mediaType: interop.Enum<typeof MPMediaType>;

  readonly title: string;

  readonly albumTitle: string;

  readonly albumPersistentID: number;

  readonly artist: string;

  readonly artistPersistentID: number;

  readonly albumArtist: string;

  readonly albumArtistPersistentID: number;

  readonly genre: string;

  readonly genrePersistentID: number;

  readonly composer: string;

  readonly composerPersistentID: number;

  readonly playbackDuration: number;

  readonly albumTrackNumber: number;

  readonly albumTrackCount: number;

  readonly discNumber: number;

  readonly discCount: number;

  readonly artwork: MPMediaItemArtwork;

  readonly explicitItem: boolean;

  readonly lyrics: string;

  readonly compilation: boolean;

  readonly releaseDate: NSDate;

  readonly beatsPerMinute: number;

  readonly comments: string;

  readonly assetURL: NSURL;

  readonly cloudItem: boolean;

  readonly protectedAsset: boolean;

  readonly podcastTitle: string;

  readonly podcastPersistentID: number;

  readonly playCount: number;

  readonly skipCount: number;

  readonly rating: number;

  readonly lastPlayedDate: NSDate;

  readonly userGrouping: string;

  readonly bookmarkTime: number;

  readonly dateAdded: NSDate;

  readonly playbackStoreID: string;

  readonly preorder: boolean;

  isExplicitItem(): boolean;

  isCompilation(): boolean;

  isCloudItem(): boolean;

  hasProtectedAsset(): boolean;

  isPreorder(): boolean;

  static persistentIDPropertyForGroupingType(groupingType: interop.Enum<typeof MPMediaGrouping>): string;

  static titlePropertyForGroupingType(groupingType: interop.Enum<typeof MPMediaGrouping>): string;
}

declare class MPNowPlayingInfoLanguageOptionGroup extends NSObject {
  initWithLanguageOptionsDefaultLanguageOptionAllowEmptySelection(languageOptions: NSArray<interop.Object> | Array<interop.Object>, defaultLanguageOption: MPNowPlayingInfoLanguageOption | null, allowEmptySelection: boolean): this;

  readonly languageOptions: NSArray;

  readonly defaultLanguageOption: MPNowPlayingInfoLanguageOption;

  readonly allowEmptySelection: boolean;
}

declare class MPAdTimeRange extends NSObject implements NSCopying {
  timeRange: CMTimeRange;

  initWithTimeRange(timeRange: CMTimeRange): this;

  setTimeRange(timeRange: CMTimeRange): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class MPVolumeView extends UIView implements NSCoding {
  showsVolumeSlider: boolean;

  showsRouteButton: boolean;

  readonly wirelessRoutesAvailable: boolean;

  readonly wirelessRouteActive: boolean;

  setMinimumVolumeSliderImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  setMaximumVolumeSliderImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  setVolumeThumbImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  minimumVolumeSliderImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  maximumVolumeSliderImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  volumeThumbImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  volumeWarningSliderImage: UIImage;

  volumeSliderRectForBounds(bounds: CGRect): CGRect;

  volumeThumbRectForBoundsVolumeSliderRectValue(bounds: CGRect, rect: CGRect, value: number): CGRect;

  setRouteButtonImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  routeButtonImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  routeButtonRectForBounds(bounds: CGRect): CGRect;

  setShowsVolumeSlider(showsVolumeSlider: boolean): void;

  setShowsRouteButton(showsRouteButton: boolean): void;

  areWirelessRoutesAvailable(): boolean;

  isWirelessRouteActive(): boolean;

  setVolumeWarningSliderImage(volumeWarningSliderImage: UIImage): void;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class MPFeedbackCommandEvent extends MPRemoteCommandEvent {
  readonly negative: boolean;

  isNegative(): boolean;
}

